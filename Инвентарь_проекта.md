# Инвентарь проекта
_Сгенерировано: 2025-10-28 18:38:45_

## 1. Полная структура (относительно корня)

```
planner/
├── core/
│   ├── priorities.py (2094 B)
│   └── settings.py (0 B)
├── models/
│   ├── __init__.py (0 B)
│   └── task.py (629 B)
├── services/
│   ├── __init__.py (0 B)
│   ├── google_auth.py (1900 B)
│   ├── google_calendar.py (7298 B)
│   ├── sync.py (8652 B)
│   └── tasks.py (10107 B)
├── storage/
│   ├── __init__.py (0 B)
│   ├── db.py (290 B)
│   └── gcal_sync_token.json (61 B)
├── ui/
│   ├── pages/
│   │   ├── __init__.py (0 B)
│   │   ├── calendar.py (50454 B)
│   │   ├── history.py (9927 B)
│   │   ├── settings.py (1472 B)
│   │   └── today.py (25889 B)
│   ├── __init__.py (0 B)
│   └── app_shell.py (9226 B)
├── .gitignore (301 B)
├── app.db (20480 B)
├── client_secret_321977136899-7lmhos5q0dntmob4ehjg28cu2gfs7q3m.apps.googleusercontent.com.json (409 B)
├── main.py (612 B)
├── push_to_github.py (7849 B)
├── README.md (44 B)
├── requirements.txt (306 B)
├── run_silent.vbs (242 B)
├── scrpt2txt.py (10866 B)
├── start_planner.bat (1508 B)
└── token.json (737 B)
```

## 2. Скрипты (всего: 21)

### core/priorities.py
```python
"""Utility helpers for task priorities."""
from __future__ import annotations

from typing import Dict

# Priority levels are intentionally limited to keep the UI compact and easy to scan.
# 0 — default/no priority, 1 — low, 2 — medium, 3 — high.
PRIORITY_META: Dict[int, Dict[str, str]] = {
    0: {
        "label": "Без приоритета",
        "short": "Без",
        "color": "#64748B",    # slate-500
        "bgcolor": "#E2E8F0",  # slate-200
    },
    1: {
        "label": "Низкий приоритет",
        "short": "Низкий",
        "color": "#0EA5E9",    # sky-500
        "bgcolor": "#E0F2FE",  # sky-100
    },
    2: {
        "label": "Средний приоритет",
        "short": "Средний",
        "color": "#F59E0B",    # amber-500
        "bgcolor": "#FEF3C7",  # amber-100
    },
    3: {
        "label": "Высокий приоритет",
        "short": "Высокий",
        "color": "#EF4444",    # red-500
        "bgcolor": "#FEE2E2",  # red-100
    },
}

DEFAULT_PRIORITY = 0


def normalize_priority(value: int | str | None) -> int:
    """Clamp external values to the supported priority range."""
    if value is None:
        return DEFAULT_PRIORITY
    try:
        ivalue = int(value)
    except (TypeError, ValueError):
        return DEFAULT_PRIORITY
    floor = min(PRIORITY_META.keys())
    ceil = max(PRIORITY_META.keys())
    return max(floor, min(ceil, ivalue))


def priority_label(value: int, *, short: bool = False) -> str:
    meta = PRIORITY_META.get(value, PRIORITY_META[DEFAULT_PRIORITY])
    return meta["short" if short else "label"]


def priority_color(value: int) -> str:
    meta = PRIORITY_META.get(value, PRIORITY_META[DEFAULT_PRIORITY])
    return meta["color"]


def priority_bgcolor(value: int) -> str:
    meta = PRIORITY_META.get(value, PRIORITY_META[DEFAULT_PRIORITY])
    return meta["bgcolor"]


def priority_options() -> Dict[str, str]:
    """Return mapping of dropdown values -> labels."""
    return {str(level): meta["label"] for level, meta in PRIORITY_META.items()}

```

### core/settings.py
```python

```

### main.py
```python
# planner/main.py
import os, sys
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
import flet as ft
from storage.db import init_db
from ui.app_shell import AppShell



def main(page: ft.Page):
    page.title = "Planner"
    page.theme_mode = "system"
    page.theme = ft.Theme(color_scheme_seed=ft.Colors.INDIGO)  # приятный базовый цвет
    page.appbar = ft.AppBar(title=ft.Text("Planner"), center_title=False)
    page.padding = 0
    page.window_min_width = 900
    page.window_min_height = 600

    init_db()
    shell = AppShell(page)
    shell.mount()

ft.app(target=main)

```

### models/__init__.py
```python

```

### models/task.py
```python
# planner/models/task.py
from typing import Optional
from datetime import datetime
from sqlmodel import SQLModel, Field

class Task(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    title: str
    notes: Optional[str] = None
    start: Optional[datetime] = None
    due: Optional[datetime] = None
    duration_minutes: Optional[int] = None
    priority: int = 0
    status: str = "todo"          # todo / doing / done
    gcal_event_id: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)

```

### push_to_github.py
```python
# -*- coding: utf-8 -*-
"""
push_to_github.py — инициализация git-репозитория и пуш на GitHub.

Пример:
  python push_to_github.py --remote https://github.com/Vitac86/Planner.git --name "Vitaly" --email vitac868686@gmail.com --lfs --git "C:\\Program Files\\Git\\bin\\git.exe"
"""

import argparse
import os
import shutil
import subprocess
import sys
from pathlib import Path
from textwrap import dedent


DEFAULT_GITIGNORE = dedent("""\
    # Byte-compiled / cache
    __pycache__/
    *.py[cod]
    *$py.class

    # Environments
    .env
    .venv/
    venv/

    # Editors/IDE
    .idea/
    .vscode/
    *.iml

    # Build artifacts
    build/
    dist/
    *.egg-info/

    # Logs
    *.log

    # OS junk
    .DS_Store
    Thumbs.db

    # Project data (ignore by default)
    data/*.db
    *.sqlite
    *.sqlite3
    *.tsv
    *.csv
    *.tmp
""")

DEFAULT_GITATTRIBUTES_LFS = dedent("""\
    *.db filter=lfs diff=lfs merge=lfs -text
    *.sqlite filter=lfs diff=lfs merge=lfs -text
    *.sqlite3 filter=lfs diff=lfs merge=lfs -text
    *.tsv filter=lfs diff=lfs merge=lfs -text
    *.csv filter=lfs diff=lfs merge=lfs -text
    *.bin filter=lfs diff=lfs merge=lfs -text
""")


def find_git(explicit: str | None) -> str:
    # 1) явный путь из аргумента/переменных окружения
    for candidate in [explicit, os.environ.get("GIT_EXE"), os.environ.get("GIT")]:
        if candidate and Path(candidate).exists():
            return str(Path(candidate))

    # 2) в PATH
    which = shutil.which("git")
    if which:
        return which

    # 3) типичные пути Git for Windows
    common_paths = [
        r"C:\Users\V.Pyatakov\AppData\Local\Programs\Git\cmd\git.exe",
        r"C:\Program Files\Git\cmd\git.exe",
        r"C:\Program Files (x86)\Git\bin\git.exe",
        r"C:\Program Files (x86)\Git\cmd\git.exe",
    ]
    for p in common_paths:
        if Path(p).exists():
            return p

    raise FileNotFoundError("git не найден. Установите Git for Windows или укажите путь параметром --git.")


def run(cmd, cwd=None, check=True):
    result = subprocess.run(cmd, cwd=cwd, text=True, capture_output=True, shell=False)
    if check and result.returncode != 0:
        raise RuntimeError(f"Command failed: {' '.join(cmd)}\nSTDOUT:\n{result.stdout}\nSTDERR:\n{result.stderr}")
    return result


def run_git(git_exe: str, args: list[str], cwd: Path, check=True):
    return run([git_exe] + args, cwd=cwd, check=check)


def ensure_in_repo(git: str, project_dir: Path, branch: str):
    git_dir = project_dir / ".git"
    if git_dir.exists():
        run_git(git, ["rev-parse", "--is-inside-work-tree"], project_dir)
    else:
        run_git(git, ["init"], project_dir)
        run_git(git, ["branch", "-M", branch], project_dir)


def git_config(git: str, project_dir: Path, name: str | None, email: str | None):
    if name:
        run_git(git, ["config", "user.name", name], project_dir)
    if email:
        run_git(git, ["config", "user.email", email], project_dir)
    run_git(git, ["config", "core.autocrlf", "true"], project_dir)
    run_git(git, ["config", "core.longpaths", "true"], project_dir)


def ensure_file_contains(path: Path, content: str):
    if path.exists():
        existing = path.read_text(encoding="utf-8", errors="ignore")
        to_add = []
        have = set(line.rstrip() for line in existing.splitlines())
        for line in content.splitlines():
            if line.rstrip() not in have:
                to_add.append(line)
        if to_add:
            with path.open("a", encoding="utf-8") as f:
                f.write(("\n" if not existing.endswith("\n") else "") + "\n".join(to_add) + "\n")
    else:
        path.write_text(content, encoding="utf-8")


def setup_ignores(git: str, project_dir: Path, apply_lfs: bool):
    gi = project_dir / ".gitignore"
    ensure_file_contains(gi, DEFAULT_GITIGNORE)

    if apply_lfs:
        # Идемпотентно: если lfs не установлен, просто предупреждаем
        try:
            run_git(git, ["lfs", "install"], project_dir, check=False)
        except Exception:
            pass
        ga = project_dir / ".gitattributes"
        ensure_file_contains(ga, DEFAULT_GITATTRIBUTES_LFS)


def ensure_readme(project_dir: Path):
    readme = project_dir / "README.md"
    if not readme.exists():
        readme.write_text("# Project\n\nОписание проекта.\n", encoding="utf-8")


def initial_commit_if_needed(git: str, project_dir: Path, message: str):
    run_git(git, ["add", "."], project_dir)
    status = run_git(git, ["status", "--porcelain"], project_dir)
    if status.stdout.strip():
        run_git(git, ["commit", "-m", message], project_dir)
    else:
        print("Нет изменений для коммита — пропускаю commit.")


def set_remote(git: str, project_dir: Path, remote_url: str, remote_name: str = "origin"):
    remotes = run_git(git, ["remote"], project_dir)
    if remote_name in remotes.stdout.split():
        run_git(git, ["remote", "set-url", remote_name, remote_url], project_dir)
    else:
        run_git(git, ["remote", "add", remote_name, remote_url], project_dir)


def push(git: str, project_dir: Path, branch: str, remote_name: str = "origin"):
    try:
        run_git(git, ["push", "-u", remote_name, branch], project_dir, check=True)
    except RuntimeError:
        print("Первый push не удался. Пробую pull --rebase и повторный push ...", file=sys.stderr)
        run_git(git, ["pull", "--rebase", remote_name, branch], project_dir, check=False)
        run_git(git, ["push", "--force-with-lease", remote_name, branch], project_dir, check=True)


def main():
    parser = argparse.ArgumentParser(description="Подготовка и публикация проекта на GitHub.")
    parser.add_argument("--project-dir", default=".", help="Корень проекта (по умолчанию текущая папка).")
    parser.add_argument("--remote", required=True, help="URL удалённого репозитория, напр. https://github.com/user/repo.git")
    parser.add_argument("--branch", default="main", help="Имя основной ветки (по умолчанию main).")
    parser.add_argument("--name", default=None, help="Git user.name (необязательно).")
    parser.add_argument("--email", default=None, help="Git user.email (необязательно).")
    parser.add_argument("--message", default="Initial commit", help="Сообщение первого коммита.")
    parser.add_argument("--lfs", action="store_true", help="Включить Git LFS трекинг больших файлов.")
    parser.add_argument("--git", default=None, help="Полный путь к git.exe (если не в PATH).")
    args = parser.parse_args()

    project_dir = Path(args.project_dir).resolve()
    if not project_dir.exists():
        print(f"Папка не найдена: {project_dir}", file=sys.stderr)
        sys.exit(1)

    git_exe = find_git(args.git)
    print(f"Использую git: {git_exe}")

    ensure_in_repo(git_exe, project_dir, args.branch)
    git_config(git_exe, project_dir, args.name, args.email)
    setup_ignores(git_exe, project_dir, apply_lfs=args.lfs)
    ensure_readme(project_dir)
    initial_commit_if_needed(git_exe, project_dir, args.message)
    set_remote(git_exe, project_dir, args.remote)
    push(git_exe, project_dir, args.branch)

    print("\nГотово! Проект отправлен на GitHub.\nЕсли спросит логин/пароль — используйте GitHub-логин и Personal Access Token.")


if __name__ == "__main__":
    main()

```

### scrpt2txt.py
```python
# -*- coding: utf-8 -*-
"""
project_inventory.py
Инвентаризация проекта:
1) Полное дерево каталогов/файлов от корня (относительные пути).
2) Сборка указанных "скриптовых" файлов в единый Markdown с кодовыми блоками.

Пример:
  python project_inventory.py --root "D:/Work/BigProj" --out "Инвентарь.md" --ext .py .lua .sql -v
"""
from __future__ import annotations
import os
import sys
import argparse
import traceback
from pathlib import Path
from typing import Iterable, List, Tuple, Sequence
import datetime as _dt

HERE = Path(__file__).resolve().parent

# Автовыбор корня как в твоём примере (при желании поправь под себя)
if (HERE / "crm" / "scripts").is_dir():
    DEFAULT_ROOT = HERE / "crm" / "scripts"
else:
    DEFAULT_ROOT = HERE

DEFAULT_OUT = HERE / "Инвентарь_проекта.md"

IGNORE_DIRS = {
    "__pycache__", ".git", ".idea", ".vscode",
    "venv", ".venv", "env", ".mypy_cache", ".pytest_cache", ".ruff_cache",
    "dist", "build", "node_modules",
}

IGNORE_FILES = set()  # можно добавить маски или имена, если нужно

# ---------- утилиты ----------
def eprint(*a, **kw):
    print(*a, file=sys.stderr, flush=True, **kw)

def vprint(verbose: bool, *a, **kw):
    if verbose:
        print(*a, flush=True, **kw)

def _lang_for(path: str) -> str:
    p = path.lower()
    if p.endswith(".py"): return "python"
    if p.endswith(".lua"): return "lua"
    if p.endswith(".sql"): return "sql"
    if p.endswith(".js"): return "javascript"
    if p.endswith(".ts"): return "typescript"
    if p.endswith(".json"): return "json"
    if p.endswith(".sh"): return "bash"
    if p.endswith(".ps1"): return "powershell"
    if p.endswith(".bat") or p.endswith(".cmd"): return ""
    if p.endswith(".yml") or p.endswith(".yaml"): return "yaml"
    if p.endswith(".ini") or p.endswith(".cfg"): return ""
    return ""

def _safe_rel(path: Path, root: Path) -> str:
    rel = path.relative_to(root)
    return str(rel).replace("\\", "/")

# ---------- сбор дерева ----------
def build_tree_lines(root: Path,
                     ignore_dirs: Iterable[str],
                     ignore_files: Iterable[str],
                     verbose: bool = False) -> List[str]:
    """
    Возвращает "красивое" дерево (список строк) со всеми файлами/папками.
    """
    root = root.resolve()
    ignore_dirs = set(ignore_dirs)
    ignore_files = set(ignore_files)

    if not root.exists():
        raise FileNotFoundError(f"Папка не найдена: {root}")
    if not root.is_dir():
        raise NotADirectoryError(f"Это не папка: {root}")

    vprint(verbose, f"[tree] старт: {root}")
    lines: List[str] = [f"{root.name}/"]

    # Для детерминированности сортируем
    def dir_entries(p: Path) -> Tuple[List[Path], List[Path]]:
        dirs, files = [], []
        for child in p.iterdir():
            name = child.name
            if child.is_dir():
                if name in ignore_dirs:
                    vprint(verbose, f"  └─ skip dir: {child}")
                    continue
                dirs.append(child)
            else:
                if name in ignore_files:
                    vprint(verbose, f"  └─ skip file: {child}")
                    continue
                files.append(child)
        return sorted(dirs, key=lambda x: x.name.lower()), sorted(files, key=lambda x: x.name.lower())

    def walk(node: Path, prefix: str):
        dirs, files = dir_entries(node)
        total = len(dirs) + len(files)
        for i, d in enumerate(dirs):
            is_last = (i == len(dirs) - 1) and (len(files) == 0)
            branch = "└── " if is_last else "├── "
            lines.append(f"{prefix}{branch}{d.name}/")
            new_prefix = f"{prefix}{'    ' if is_last else '│   '}"
            walk(d, new_prefix)

        for j, f in enumerate(files):
            is_last_file = (j == len(files) - 1)
            branch = "└── " if is_last_file else "├── "
            try:
                size = f.stat().st_size
                size_note = f" ({size} B)"
            except OSError:
                size_note = ""
            lines.append(f"{prefix}{branch}{f.name}{size_note}")

    walk(root, "")
    vprint(verbose, f"[tree] готово: {len(lines)} строк")
    return lines

# ---------- сбор скриптов ----------
def collect_scripts(root: Path,
                    exts: Iterable[str],
                    ignore_dirs: Iterable[str],
                    max_size_mb: float | None = None,
                    verbose: bool = False) -> List[Tuple[str, str]]:
    """
    Рекурсивно собирает файлы расширений exts из root.
    Возвращает список (relative_path, code).
    """
    root = root.resolve()
    exts = tuple(e.lower() for e in exts)
    ignore = set(ignore_dirs)

    if not root.exists():
        raise FileNotFoundError(f"Папка не найдена: {root}")
    if not root.is_dir():
        raise NotADirectoryError(f"Это не папка: {root}")

    scripts: List[Tuple[str, str]] = []
    vprint(verbose, f"[collect] старт: {root}")

    for dirpath, dirnames, filenames in os.walk(root):
        before = list(dirnames)
        dirnames[:] = [d for d in dirnames if d not in ignore]
        dropped = set(before) - set(dirnames)
        if dropped and verbose:
            vprint(verbose, f"  └─ skip dirs: {', '.join(sorted(dropped))}")

        for fname in filenames:
            if not any(fname.lower().endswith(ext) for ext in exts):
                continue
            fpath = Path(dirpath) / fname

            try:
                if max_size_mb is not None and fpath.stat().st_size > max_size_mb * 1024 * 1024:
                    vprint(verbose, f"  └─ skip big file: {fpath}")
                    continue
            except OSError as ex:
                eprint(f"[warn] не удалось получить размер: {fpath} ({ex})")
                continue

            try:
                code = fpath.read_text(encoding="utf-8", errors="replace")
            except OSError as ex:
                eprint(f"[warn] не удалось прочитать: {fpath} ({ex})")
                continue

            rel_str = _safe_rel(fpath, root)
            scripts.append((rel_str, code))
            vprint(verbose, f"  + {rel_str}")

    scripts.sort(key=lambda x: x[0].lower())
    vprint(verbose, f"[collect] готово: файлов {len(scripts)}")
    return scripts

# ---------- запись отчёта ----------
def write_report(tree_lines: Sequence[str],
                 scripts: Sequence[Tuple[str, str]],
                 output_file: Path,
                 verbose: bool = False) -> None:
    output_file = output_file.resolve()
    output_file.parent.mkdir(parents=True, exist_ok=True)
    vprint(verbose, f"[write] -> {output_file}")

    ts = _dt.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    with open(output_file, "w", encoding="utf-8", newline="\n") as out:
        # Шапка
        out.write(f"# Инвентарь проекта\n")
        out.write(f"_Сгенерировано: {ts}_\n\n")

        # Раздел 1: Полная структура
        out.write("## 1. Полная структура (относительно корня)\n\n")
        out.write("```\n")
        for line in tree_lines:
            out.write(line)
            out.write("\n")
        out.write("```\n\n")

        # Раздел 2: Содержимое скриптов
        out.write(f"## 2. Скрипты (всего: {len(scripts)})\n\n")
        for relpath, code in scripts:
            lang = _lang_for(relpath)
            out.write(f"### {relpath}\n")
            out.write(f"```{lang}\n")
            out.write(code)
            out.write("\n```\n\n")

# ---------- CLI ----------
def main(argv: list[str] | None = None) -> int:
    ap = argparse.ArgumentParser(description="Инвентаризация проекта: дерево и сборка скриптов в Markdown.")
    ap.add_argument("--root", type=str, default=str(DEFAULT_ROOT),
                    help=f"Корневая папка (по умолчанию: {DEFAULT_ROOT})")
    ap.add_argument("--out", type=str, default=str(DEFAULT_OUT),
                    help=f"Итоговый Markdown-файл (по умолчанию: {DEFAULT_OUT})")
    ap.add_argument("--ext", nargs="+", default=[".py"],
                    help="Расширения скриптов (напр.: --ext .py .lua .sql .js .ts)")
    ap.add_argument("--max-size-mb", type=float, default=None,
                    help="Максимальный размер файла (МБ) для включения в сборку кода")
    ap.add_argument("-v", "--verbose", action="store_true", help="Подробный вывод")
    args = ap.parse_args(argv)

    root = Path(args.root)
    out = Path(args.out)

    print(f"[run] root={root}")
    print(f"[run] out ={out}")
    print(f"[run] ext ={', '.join(args.ext)}")
    if args.max_size_mb is not None:
        print(f"[run] max_size_mb={args.max_size_mb}")

    tree = build_tree_lines(root, IGNORE_DIRS, IGNORE_FILES, verbose=args.verbose)
    scripts = collect_scripts(root, exts=args.ext, ignore_dirs=IGNORE_DIRS,
                              max_size_mb=args.max_size_mb, verbose=args.verbose)
    write_report(tree, scripts, out, verbose=args.verbose)
    print(f"Строк в дереве: {len(tree)}")
    print(f"Скриптов собрано: {len(scripts)}")
    print(f"Готово: {out}")
    return 0

if __name__ == "__main__":
    try:
        sys.exit(main())
    except SystemExit:
        raise
    except Exception:
        # Всегда пишем трейсбек в лог, чтобы не «падать молча»
        log_path = Path(__file__).with_name("project_inventory_error.log")
        tb = traceback.format_exc()
        try:
            log_path.write_text(tb, encoding="utf-8")
        except Exception:
            pass
        eprint("[fatal] скрипт завершился с ошибкой. См. лог:", log_path)
        eprint(tb)
        if os.name == "nt" and not sys.stdin.isatty():
            os.system("pause")
        sys.exit(1)

```

### services/__init__.py
```python

```

### services/google_auth.py
```python
# planner/services/google_auth.py
from pathlib import Path
from typing import Optional
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import InstalledAppFlow
from google.auth.transport.requests import Request

SCOPES = ["https://www.googleapis.com/auth/calendar"]

class GoogleAuth:
    def __init__(self, secrets_path: str | Path = "client_secret_321977136899-7lmhos5q0dntmob4ehjg28cu2gfs7q3m.apps.googleusercontent.com.json",
                 token_path: str | Path = "token.json"):
        self.secrets_path = Path(secrets_path)
        self.token_path = Path(token_path)
        self.creds: Optional[Credentials] = None

    def ensure_credentials(self) -> bool:
        if self.creds and self.creds.valid:
            return True

        if self.token_path.exists():
            self.creds = Credentials.from_authorized_user_file(
                str(self.token_path), SCOPES
            )

        if not self.creds or not self.creds.valid:
            if self.creds and self.creds.expired and self.creds.refresh_token:
                self.creds.refresh(Request())
            else:
                if not self.secrets_path.exists():
                    raise FileNotFoundError(
                        f"Не найден {self.secrets_path}. "
                        "Создайте OAuth-клиент (Desktop) в Google Cloud и скачайте JSON."
                    )
                flow = InstalledAppFlow.from_client_secrets_file(
                    str(self.secrets_path), SCOPES
                )
                # Откроет браузер и поднимет локальный сервер для callback
                self.creds = flow.run_local_server(port=0)

            # Сохраняем полученный токен
            self.token_path.write_text(self.creds.to_json(), encoding="utf-8")

        return True

```

### services/google_calendar.py
```python
from __future__ import annotations

import os
from datetime import datetime, timedelta
from typing import Any, Dict, List, Optional

from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
try:
    from google.oauth2.credentials import Credentials
except Exception:
    Credentials = None

DEFAULT_SCOPES = ["https://www.googleapis.com/auth/calendar"]

# ---------- время в RFC3339 ----------
def _ensure_tz(dt: datetime) -> datetime:
    if dt.tzinfo is None:
        dt = datetime.now().astimezone().replace(year=dt.year, month=dt.month, day=dt.day,
                                                 hour=dt.hour, minute=dt.minute, second=dt.second, microsecond=dt.microsecond)
    return dt.astimezone()

def _to_rfc3339(dt: datetime) -> str:
    return _ensure_tz(dt).isoformat()

def _path_exists(p) -> bool:
    try:
        return os.path.exists(os.fspath(p))
    except Exception:
        return False

# ---------- извлечение сервиса из auth ----------
def _build_service_from_creds(creds) -> Any:
    if creds is None:
        return None
    return build("calendar", "v3", credentials=creds)

def _find_creds_in_auth(auth, scopes: Optional[List[str]] = None):
    for name in ("get_credentials", "credentials", "creds"):
        val = getattr(auth, name, None)
        if callable(val):
            try:
                val = val()
            except Exception:
                val = None
        if val is not None and hasattr(val, "valid"):
            return val

    token_path = None
    for attr in ("token_path", "token_file", "token", "token_json"):
        p = getattr(auth, attr, None)
        if p and _path_exists(p):
            token_path = os.fspath(p)
            break
    if token_path and Credentials:
        try:
            return Credentials.from_authorized_user_file(token_path, scopes or DEFAULT_SCOPES)
        except Exception:
            pass
    return None

def _find_service_in_auth(auth) -> Any:
    for attr in ("calendar_service", "calendar", "service", "svc", "calendar_v3"):
        svc = getattr(auth, attr, None)
        if svc and hasattr(svc, "events"):
            return svc
    for meth in ("get_calendar_service", "build_calendar_service", "create_calendar_service"):
        if hasattr(auth, meth) and callable(getattr(auth, meth)):
            svc = getattr(auth, meth)()
            if svc and hasattr(svc, "events"):
                return svc
    for meth in ("get_service", "service_for", "build_service"):
        if hasattr(auth, meth) and callable(getattr(auth, meth)):
            try:
                svc = getattr(auth, meth)("calendar", "v3")
            except TypeError:
                svc = getattr(auth, meth)("calendar")
            if svc and hasattr(svc, "events"):
                return svc
    return None

# ---------- основной класс ----------
class GoogleCalendar:
    """
    Совместим с GoogleCalendar(self.auth) из AppShell.
    Ставит маркер planner_task_id:<id> в description для двусторонней синхронизации.
    """
    def __init__(self, auth, calendar_id: str = "primary"):
        self.auth = auth
        self.calendar_id = getattr(auth, "calendar_id", None) or calendar_id
        self.service = None
        self._maybe_build_service()

    def connect(self):
        if hasattr(self.auth, "ensure_credentials") and callable(getattr(self.auth, "ensure_credentials")):
            self.auth.ensure_credentials()
        self._maybe_build_service(strict=True)
        return True

    def _maybe_build_service(self, strict: bool = False):
        if self.service and hasattr(self.service, "events"):
            return
        svc = _find_service_in_auth(self.auth)
        if svc:
            self.service = svc
            return
        creds = _find_creds_in_auth(self.auth, DEFAULT_SCOPES)
        if creds:
            self.service = _build_service_from_creds(creds)
            return
        if strict:
            raise RuntimeError(
                "GoogleCalendar: не удалось собрать сервис из auth. Нужен token.json "
                "или ensure_credentials(), или get_credentials()/credentials/creds, "
                "или готовый service в auth."
            )

    # ----- utils для маркера -----
    @staticmethod
    def _with_marker(task, notes: Optional[str]) -> str:
        base = (notes or "").strip()
        marker = f"planner_task_id:{getattr(task, 'id', '')}"
        return f"{base}\n{marker}" if base else marker

    @staticmethod
    def parse_task_id_from_description(desc: Optional[str]) -> Optional[int]:
        if not desc:
            return None
        key = "planner_task_id:"
        try:
            for line in desc.splitlines():
                line = line.strip()
                if line.startswith(key):
                    return int(line[len(key):].strip())
        except Exception:
            return None
        return None

    # ----- операции -----
    def list_range(self, start_dt: datetime, end_dt: datetime, show_deleted: bool = False) -> List[Dict[str, Any]]:
        self._maybe_build_service(strict=True)
        params = dict(
            calendarId=self.calendar_id,
            timeMin=_to_rfc3339(start_dt),
            timeMax=_to_rfc3339(end_dt),
            singleEvents=True,
            orderBy="startTime",
            maxResults=2500,
        )
        if show_deleted:
            params["showDeleted"] = True
        res = self.service.events().list(**params).execute()
        return res.get("items", [])

    def create_event_for_task(self, task, start_dt: datetime, duration_minutes: int) -> Dict[str, Any]:
        self._maybe_build_service(strict=True)
        end_dt = _ensure_tz(start_dt) + timedelta(minutes=duration_minutes)
        body = {
            "summary": getattr(task, "title", "Задача"),
            "description": self._with_marker(task, getattr(task, "notes", None)),
            "start": {"dateTime": _to_rfc3339(start_dt)},
            "end": {"dateTime": _to_rfc3339(end_dt)},
        }
        return self.service.events().insert(calendarId=self.calendar_id, body=body).execute()

    def update_event_for_task(self, event_id: str, task, start_dt: datetime, duration_minutes: int) -> Dict[str, Any]:
        self._maybe_build_service(strict=True)
        end_dt = _ensure_tz(start_dt) + timedelta(minutes=duration_minutes)
        body = {
            "summary": getattr(task, "title", "Задача"),
            "description": self._with_marker(task, getattr(task, "notes", None)),
            "start": {"dateTime": _to_rfc3339(start_dt)},
            "end": {"dateTime": _to_rfc3339(end_dt)},
        }
        return self.service.events().patch(
            calendarId=self.calendar_id, eventId=event_id, body=body
        ).execute()

    def delete_event_by_id(self, event_id: str) -> None:
        self._maybe_build_service(strict=True)
        try:
            self.service.events().delete(calendarId=self.calendar_id, eventId=event_id).execute()
        except HttpError as e:
            if getattr(e, "resp", None) and getattr(e.resp, "status", None) == 404:
                return
            raise

```

### services/sync.py
```python
# services/sync.py
from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Optional
from datetime import datetime, timezone, timedelta

from services.tasks import TaskService

DELETE_ON_GOOGLE_CANCEL = False  # True — удалять задачу; False — только снимать расписание (как сейчас)
_MARKER_RE = re.compile(r"planner_task_id\s*:\s*(\d+)", re.I)


class JsonTokenStore:
    """Простейшее хранение syncToken в файле (чтобы получать только изменения)."""
    def __init__(self, path: str | Path = "storage/gcal_sync_token.json"):
        self.path = Path(path)

    def get_sync_token(self) -> Optional[str]:
        try:
            data = json.loads(self.path.read_text(encoding="utf-8"))
            return data.get("syncToken")
        except Exception:
            return None

    def set_sync_token(self, token: str):
        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.path.write_text(json.dumps({"syncToken": token}), encoding="utf-8")


def _parse_marker(description: str | None) -> Optional[int]:
    if not description:
        return None
    m = _MARKER_RE.search(description)
    if not m:
        return None
    try:
        return int(m.group(1))
    except Exception:
        return None


def _strip_marker(description: str | None) -> str:
    if not description:
        return ""
    lines = [ln for ln in description.splitlines() if not _MARKER_RE.search(ln)]
    return "\n".join(lines).strip()


def _parse_g_datetime(obj: dict | None) -> Optional[datetime]:
    """start/end из Google: либо {'dateTime': '...Z'}, либо {'date': 'YYYY-MM-DD'}."""
    if not obj:
        return None
    if "dateTime" in obj and obj["dateTime"]:
        # RFC3339; делаем tz-aware
        s = str(obj["dateTime"]).replace("Z", "+00:00")
        try:
            return datetime.fromisoformat(s)
        except Exception:
            return None
    if "date" in obj and obj["date"]:
        # all-day -> в полночь локального дня (без tz; дальше ты сам решаешь как отображать)
        try:
            d = datetime.fromisoformat(str(obj["date"]))
            return d  # 00:00
        except Exception:
            # некоторые клиенты присылают 'YYYY-MM-DD' -> отработает
            try:
                y, m, dd = str(obj["date"]).split("-")
                return datetime(int(y), int(m), int(dd))
            except Exception:
                return None
    return None


class GoogleSync:
    """
    Двусторонняя связка:
      - Если событие в Google помечено marker'ом planner_task_id:NN — обновляем соответствующую локальную задачу.
      - Если marker'а нет, но мы видим event_id == Task.gcal_event_id — обновляем эту задачу.
      - Если marker'а нет и event_id незнаком — создаём новую локальную задачу и обратно проставляем marker в событие.
      - Если событие в Google отменено (status=cancelled) — снимаем расписание у соответствующей задачи (не удаляем).
    """
    def __init__(self, gcal_service, calendar_id: str, token_store: JsonTokenStore | None = None):
        self.service = gcal_service
        self.calendar_id = calendar_id
        self.store = token_store or JsonTokenStore()
        self.svc = TaskService()

    def pull(self) -> bool:
        """Возвращает True, если что-то изменилось в локальной базе."""
        if not self.service or not self.calendar_id:
            return False

        changed = False
        token = self.store.get_sync_token()

        params = dict(
            calendarId=self.calendar_id,
            singleEvents=True,
            showDeleted=True,
            maxResults=250,
        )
        if token:
            # инкрементальные изменения
            params["syncToken"] = token
        else:
            # первичная выгрузка за последние 6 мес.
            params["timeMin"] = (datetime.now(timezone.utc) - timedelta(days=180)).isoformat()

        while True:
            resp = self.service.events().list(**params).execute()
            items = resp.get("items", [])

            for ev in items:
                ev_id = ev.get("id")
                status = ev.get("status")
                summary = ev.get("summary") or "Без названия"
                description = ev.get("description") or ""

                # cancelled -> снять расписание у связанной задачи (если есть)
                if status == "cancelled":
                    tid = _parse_marker(description)
                    target_task = self.svc.get(tid) if tid else self.svc.get_by_event_id(ev_id)
                    if target_task:
                        if DELETE_ON_GOOGLE_CANCEL:
                            self.svc.delete(target_task.id)
                        else:
                            self.svc.unschedule(target_task.id)
                        changed = True
                    continue

                # обычное событие
                dt_start = _parse_g_datetime(ev.get("start"))
                dt_end   = _parse_g_datetime(ev.get("end"))
                duration = None
                if dt_start and dt_end and dt_end > dt_start:
                    duration = int((dt_end - dt_start).total_seconds() // 60)

                # ищем задачу
                task = None
                tid = _parse_marker(description)
                if tid:
                    task = self.svc.get(tid)
                if task is None:
                    task = self.svc.get_by_event_id(ev_id)

                # текст заметок без служебного маркера
                notes = _strip_marker(description)

                if task:
                    # обновляем локально
                    self.svc.update(task.id, title=summary, notes=notes, start=dt_start, duration_minutes=duration)
                    if task.gcal_event_id != ev_id:
                        self.svc.set_event_id(task.id, ev_id)
                    changed = True

                    # убедимся, что в событии есть marker
                    if tid != task.id:
                        # аккуратно дописываем marker в описание, не трогая время
                        try:
                            new_desc = (notes + ("\n" if notes else "") + f"planner_task_id:{task.id}").strip()
                            self.service.events().patch(
                                calendarId=self.calendar_id,
                                eventId=ev_id,
                                body={"description": new_desc},
                            ).execute()
                        except Exception:
                            pass
                else:
                    # это новое событие «со стороны Google» — создаём задачу
                    new_task = self.svc.add(title=summary, start=dt_start, duration_minutes=duration, notes=notes)
                    self.svc.set_event_id(new_task.id, ev_id)
                    changed = True

                    # и проставим marker обратно в событии
                    try:
                        new_desc = (notes + ("\n" if notes else "") + f"planner_task_id:{new_task.id}").strip()
                        self.service.events().patch(
                            calendarId=self.calendar_id,
                            eventId=ev_id,
                            body={"description": new_desc},
                        ).execute()
                    except Exception:
                        pass

            # пагинация + syncToken
            if "nextPageToken" in resp:
                params["pageToken"] = resp["nextPageToken"]
                # не нужна timeMin/syncToken при пагинации
                params.pop("timeMin", None)
                params.pop("syncToken", None)
                continue

            if "nextSyncToken" in resp:
                self.store.set_sync_token(resp["nextSyncToken"])
            break

        return changed

```

### services/tasks.py
```python
# planner/services/tasks.py
from __future__ import annotations

import re
from datetime import datetime, date, timedelta
from typing import Iterable, List, Optional

from sqlmodel import select
from sqlalchemy import and_, or_, case

from storage.db import get_session
from models.task import Task
from core.priorities import normalize_priority


class TaskService:
    def add(
        self,
        title: str,
        notes: Optional[str] = None,
        start: Optional[datetime] = None,
        duration_minutes: Optional[int] = None,
        priority: int = 0,
    ) -> Task:
        with get_session() as s:
            t = Task(
                title=title.strip(),
                notes=notes or None,
                start=start,
                duration_minutes=duration_minutes or None,
                priority=normalize_priority(priority),
            )
            s.add(t)
            s.commit()
            s.refresh(t)
            return t

    def get(self, task_id: int) -> Optional[Task]:
        with get_session() as s:
            return s.get(Task, task_id)

    def update(
        self,
        task_id: int,
        *,
        title: Optional[str] = None,
        notes: Optional[str] = None,
        start: Optional[datetime] = None,
        duration_minutes: Optional[int] = None,
        priority: Optional[int] = None,
    ) -> Optional[Task]:
        with get_session() as s:
            t = s.get(Task, task_id)
            if not t:
                return None
            if title is not None:
                t.title = title.strip()
            if notes is not None:
                t.notes = notes or None
            if start is not None or start is None:
                t.start = start
            if duration_minutes is not None or duration_minutes is None:
                t.duration_minutes = duration_minutes
            if priority is not None:
                t.priority = normalize_priority(priority)
            t.updated_at = datetime.utcnow()
            s.add(t)
            s.commit()
            s.refresh(t)
            return t

    def set_event_id(self, task_id: int, event_id: Optional[str]):
        with get_session() as s:
            t = s.get(Task, task_id)
            if t:
                t.gcal_event_id = event_id
                t.updated_at = datetime.utcnow()
                s.add(t)
                s.commit()

    def set_status(self, task_id: int, status: str):
        with get_session() as s:
            t = s.get(Task, task_id)
            if t:
                t.status = status
                t.updated_at = datetime.utcnow()
                s.add(t)
                s.commit()

    def delete(self, task_id: int):
        with get_session() as s:
            t = s.get(Task, task_id)
            if t:
                s.delete(t)
                s.commit()

    def list_for_day(self, d: date) -> Iterable[Task]:
        start = datetime(d.year, d.month, d.day, 0, 0, 0)
        end = start + timedelta(days=1)
        with get_session() as s:
            stmt = (
                select(Task)
                .where(and_(Task.status != "done", Task.start >= start, Task.start < end))
                .order_by(Task.start.asc(), Task.priority.desc(), Task.created_at.desc())
            )
            return list(s.exec(stmt))

    def list_unscheduled(self) -> Iterable[Task]:
        with get_session() as s:
            status_order = case(
                (Task.status == "todo", 0),
                (Task.status == "doing", 1),
                (Task.status == None, 2),  # noqa: E711
                (Task.status == "", 2),
                else_=3,
            )
            stmt = (
                select(Task)
                .where(and_(Task.status != "done", Task.start == None))  # noqa: E711
                .order_by(Task.priority.desc(), status_order, Task.created_at.desc())
            )
            return list(s.exec(stmt))

    def get_by_event_id(self, gcal_event_id: str | None):
        if not gcal_event_id:
            return None
        with get_session() as s:
            stmt = select(Task).where(Task.gcal_event_id == gcal_event_id)
            return s.exec(stmt).first()

    def unschedule(self, task_id: int):
        """Снять расписание и отвязать от Google-события (но задачу не удалять)."""
        with get_session() as s:
            t = s.get(Task, task_id)
            if not t:
                return None
            t.start = None
            t.duration_minutes = None
            t.gcal_event_id = None
            s.add(t)
            s.commit()
            s.refresh(t)
            return t

    # ---------- History & search ----------
    def search_history(
        self,
        *,
        query: str = "",
        start_date: Optional[date] = None,
        end_date: Optional[date] = None,
        status: Optional[str] = None,
        priority: Optional[int] = None,
    ) -> List[Task]:
        """Return tasks filtered by the provided parameters.

        The text search is performed in Python so we can support
        transliteration-aware matching (Cyrillic/Latin/translit).
        """

        with get_session() as s:
            stmt = select(Task)

            if start_date:
                start_dt = datetime(start_date.year, start_date.month, start_date.day, 0, 0, 0)
                stmt = stmt.where(
                    or_(
                        and_(Task.start != None, Task.start >= start_dt),  # noqa: E711
                        and_(Task.start == None, Task.created_at >= start_dt),  # noqa: E711
                    )
                )

            if end_date:
                end_dt = datetime(end_date.year, end_date.month, end_date.day, 23, 59, 59)
                stmt = stmt.where(
                    or_(
                        and_(Task.start != None, Task.start <= end_dt),  # noqa: E711
                        and_(Task.start == None, Task.created_at <= end_dt),  # noqa: E711
                    )
                )

            if status and status not in ("all", ""):
                stmt = stmt.where(Task.status == status)

            if priority is not None and priority >= 0:
                stmt = stmt.where(Task.priority == normalize_priority(priority))

            stmt = stmt.order_by(
                case((Task.start == None, 1), else_=0),  # noqa: E711
                Task.start.desc(),
                Task.updated_at.desc(),
            )

            tasks = list(s.exec(stmt))

        if not query or not query.strip():
            return tasks

        return [t for t in tasks if self._match_query(query, f"{t.title} {t.notes or ''}")]

    # --- text helpers -------------------------------------------------
    _RE_SPACES = re.compile(r"\s+")
    _RE_ALLOWED = re.compile(r"[^0-9a-zа-яё\s]")

    _RU_TO_LAT = {
        "а": "a",
        "б": "b",
        "в": "v",
        "г": "g",
        "д": "d",
        "е": "e",
        "ё": "yo",
        "ж": "zh",
        "з": "z",
        "и": "i",
        "й": "y",
        "к": "k",
        "л": "l",
        "м": "m",
        "н": "n",
        "о": "o",
        "п": "p",
        "р": "r",
        "с": "s",
        "т": "t",
        "у": "u",
        "ф": "f",
        "х": "kh",
        "ц": "ts",
        "ч": "ch",
        "ш": "sh",
        "щ": "shch",
        "ъ": "",
        "ы": "y",
        "ь": "",
        "э": "e",
        "ю": "yu",
        "я": "ya",
    }

    _LAT_MULTI = [
        ("shch", "щ"),
        ("zh", "ж"),
        ("kh", "х"),
        ("ts", "ц"),
        ("ch", "ч"),
        ("sh", "ш"),
        ("yo", "ё"),
        ("yu", "ю"),
        ("ya", "я"),
        ("ye", "е"),
    ]

    _LAT_SINGLE = {
        "a": "а",
        "b": "б",
        "c": "к",
        "d": "д",
        "e": "е",
        "f": "ф",
        "g": "г",
        "h": "х",
        "i": "и",
        "j": "ж",
        "k": "к",
        "l": "л",
        "m": "м",
        "n": "н",
        "o": "о",
        "p": "п",
        "q": "к",
        "r": "р",
        "s": "с",
        "t": "т",
        "u": "у",
        "v": "в",
        "w": "в",
        "x": "кс",
        "y": "й",
        "z": "з",
    }

    def _normalize_base(self, text: str) -> str:
        cleaned = self._RE_ALLOWED.sub(" ", (text or "").lower())
        cleaned = cleaned.replace("ё", "е")
        return self._RE_SPACES.sub(" ", cleaned).strip()

    def _variants(self, text: str) -> List[str]:
        base = self._normalize_base(text)
        if not base:
            return [""]
        ru_to_lat = self._normalize_base(self._translit_ru_to_lat(base))
        lat_to_ru = self._normalize_base(self._translit_lat_to_ru(base))
        variants = {base}
        if ru_to_lat:
            variants.add(ru_to_lat)
        if lat_to_ru:
            variants.add(lat_to_ru)
        return list(variants)

    def _match_query(self, query: str, haystack: str) -> bool:
        tokens = [tok for tok in self._RE_SPACES.split(self._normalize_base(query)) if tok]
        if not tokens:
            return True
        haystack_variants = self._variants(haystack)
        for token in tokens:
            token_variants = self._variants(token)
            if not any(tv and tv in hv for hv in haystack_variants for tv in token_variants):
                return False
        return True

    def _translit_ru_to_lat(self, text: str) -> str:
        return "".join(self._RU_TO_LAT.get(ch, ch) for ch in text)

    def _translit_lat_to_ru(self, text: str) -> str:
        res: List[str] = []
        i = 0
        while i < len(text):
            matched = False
            for seq, repl in self._LAT_MULTI:
                if text.startswith(seq, i):
                    res.append(repl)
                    i += len(seq)
                    matched = True
                    break
            if matched:
                continue
            ch = text[i]
            res.append(self._LAT_SINGLE.get(ch, ch))
            i += 1
        return "".join(res)

```

### storage/__init__.py
```python

```

### storage/db.py
```python
# planner/storage/db.py
from sqlmodel import SQLModel, create_engine, Session

_engine = create_engine("sqlite:///app.db", echo=False)

def init_db():
    SQLModel.metadata.create_all(_engine)

def get_engine():
    return _engine

def get_session() -> Session:
    return Session(_engine)

```

### ui/__init__.py
```python

```

### ui/app_shell.py
```python
# ui/app_shell.py
from __future__ import annotations

import asyncio
import flet as ft

# страницы
from .pages.today import TodayPage
from .pages.calendar import CalendarPage
from .pages.settings import SettingsPage
from .pages.history import HistoryPage

# Google
from services.google_auth import GoogleAuth
from services.google_calendar import GoogleCalendar
from googleapiclient.discovery import build

# Pull-синхронизация Google -> локально
from services.sync import GoogleSync, JsonTokenStore

SAFE_SURFACE_BG = "#F1F5F9"  # вместо ft.Colors.SURFACE_VARIANT (его нет в 0.28.3)


class AppShell:
    def __init__(self, page: ft.Page):
        self.page = page

        # базовые настройки окна
        self.page.title = "Planner"
        self.page.horizontal_alignment = ft.CrossAxisAlignment.STRETCH
        self.page.vertical_alignment = ft.MainAxisAlignment.START

        # --- Google Auth + Calendar (важно: до создания страниц) ---
        # при необходимости можно передать пути: GoogleAuth(secrets_path=..., token_path=...)
        self.auth = GoogleAuth()
        self.gcal = GoogleCalendar(self.auth, calendar_id="primary")

        # --- страницы ---
        self._today = TodayPage(self)
        self._calendar = CalendarPage(self)
        self._history = HistoryPage(self)
        self._settings = SettingsPage(self)  # использует self.gcal

        # контейнер контента
        self.content = ft.Container(expand=True)

        # левое меню
        self.nav = ft.NavigationRail(
            selected_index=0,
            label_type=ft.NavigationRailLabelType.ALL,
            min_width=90,
            min_extended_width=200,
            group_alignment=-0.9,
            on_change=self.on_nav_change,
            destinations=[
                ft.NavigationRailDestination(
                    icon=ft.Icons.CHECK_CIRCLE_OUTLINE,
                    selected_icon=ft.Icons.CHECK_CIRCLE,
                    label="Сегодня",
                ),
                ft.NavigationRailDestination(
                    icon=ft.Icons.CALENDAR_MONTH_OUTLINED,
                    selected_icon=ft.Icons.CALENDAR_MONTH,
                    label="Календарь",
                ),
                ft.NavigationRailDestination(
                    icon=ft.Icons.HISTORY_EDU_OUTLINED,
                    selected_icon=ft.Icons.HISTORY,
                    label="История",
                ),
                ft.NavigationRailDestination(
                    icon=ft.Icons.SETTINGS_OUTLINED,
                    selected_icon=ft.Icons.SETTINGS,
                    label="Настройки",
                ),
            ],
        )

        # корневой лэйаут
        self.root = ft.Row(
            controls=[
                ft.Container(self.nav, width=88, bgcolor=SAFE_SURFACE_BG),
                ft.VerticalDivider(width=1),
                self.content,
            ],
            expand=True,
            spacing=0,
        )

        # автообновление активной страницы
        self._auto_task: asyncio.Task | None = None
        self._active_view: str | None = None  # "today" | "calendar" | "history" | "settings"

    def cleanup_overlays(self):
        """Remove closed overlays (dialogs, pickers, backdrops) to avoid "ghost" windows."""
        overlays = getattr(self.page, "overlay", None) or []
        changed = False

        def _close_and_remove(ctrl):
            nonlocal changed
            try:
                if hasattr(ctrl, "open"):
                    ctrl.open = False
            except Exception:
                pass
            try:
                overlays.remove(ctrl)
                changed = True
            except Exception:
                pass

        for ctrl in list(overlays):
            if isinstance(ctrl, (ft.AlertDialog, ft.DatePicker, ft.TimePicker)):
                if not getattr(ctrl, "open", False):
                    _close_and_remove(ctrl)

        has_dialog = any(
            getattr(ctrl, "open", False) for ctrl in overlays if isinstance(ctrl, ft.AlertDialog)
        )

        if not has_dialog:
            for ctrl in list(overlays):
                if getattr(ctrl, "data", None) == "backdrop":
                    _close_and_remove(ctrl)

        if changed:
            self.page.update()

    # ---------- утилиты ----------
    def _has_open_overlay(self) -> bool:
        """Если открыт любой диалог/оверлей — пропускаем автообновление."""
        try:
            if getattr(self.page, "dialog", None) and getattr(self.page.dialog, "open", False):
                return True
        except Exception:
            pass
        try:
            return any(getattr(c, "open", False) for c in (self.page.overlay or []))
        except Exception:
            return False

    def _pull_from_google(self) -> bool:
        """
        Подтягиваем изменения из Google -> локально.
        Возвращает True, если локальная база изменилась (для логов/отладки).
        """
        try:
            if not self.gcal or not getattr(self.gcal, "service", None) or not getattr(self.gcal, "calendar_id", None):
                return False
            sync = GoogleSync(self.gcal.service, self.gcal.calendar_id, JsonTokenStore())
            return sync.pull()
        except Exception as e:
            print("Google pull sync error:", e)
            return False

    def _start_auto_refresh(self, view_name: str, refresh_fn, period_sec: int = 60):
        """Периодически дергаем pull + refresh_fn, пока активен указанный view."""
        self._stop_auto_refresh()
        self._active_view = view_name

        async def _loop():
            # первый прогон — сразу: подтянуть изменения и перерисовать
            try:
                self._pull_from_google()
                refresh_fn()
            except Exception as e:
                print("auto refresh (initial):", e)

            while self._active_view == view_name:
                await asyncio.sleep(period_sec)
                if self._active_view != view_name:
                    break
                if self._has_open_overlay():
                    continue
                try:
                    self._pull_from_google()
                    refresh_fn()
                except Exception as e:
                    print("auto refresh:", e)

        self._auto_task = self.page.run_task(_loop)

    def _stop_auto_refresh(self):
        try:
            if self._auto_task:
                self._auto_task.cancel()
        except Exception:
            pass
        self._auto_task = None
        self._active_view = None

    # ---------- монтаж ----------
    def mount(self):
        self.page.controls.clear()
        self.page.add(self.root)

        # стартуем со «Сегодня»
        self.content.content = self._today.view
        self.page.update()

        # 1) Подтянуть последние изменения из Google,
        # 2) отрисовать страницу,
        # 3) запустить автообновление.
        self._pull_from_google()
        self._today.activate_from_menu()
        self._start_auto_refresh("today", self._today.load)

    # ---------- переключение вкладок ----------
    def on_nav_change(self, e: ft.ControlEvent):
        idx = int(e.control.selected_index)

        if idx == 0:  # Сегодня
            self.content.content = self._today.view
            self._pull_from_google()
            self._today.activate_from_menu()
            self._start_auto_refresh("today", self._today.load)

        elif idx == 1:  # Календарь
            self.content.content = self._calendar.view
            self._pull_from_google()
            self._calendar.activate_from_menu()
            try:
                self._calendar.scroll_to_now()  # к текущему часу
            except Exception:
                pass
            self._start_auto_refresh("calendar", self._calendar.load)

        elif idx == 2:  # История
            self.content.content = self._history.view
            self._stop_auto_refresh()
            self._history.activate_from_menu()

        else:  # Настройки (используем полноценную страницу настроек)
            self.content.content = self._settings.view
            self._stop_auto_refresh()

        self.page.update()

    # ---------- ручной вызов синка (если где-то используете) ----------
    def current_page_auto_sync(self):
        if self._has_open_overlay():
            return
        self._pull_from_google()
        if self._active_view == "calendar":
            self._calendar.load()
        elif self._active_view == "today":
            self._today.load()

```

### ui/pages/__init__.py
```python

```

### ui/pages/calendar.py
```python
# ui/pages/calendar.py
from __future__ import annotations
import re

import json
import flet as ft
from datetime import datetime, date, timedelta, time as dt_time
from typing import Dict, Tuple, List, Optional

from services.tasks import TaskService
from core.priorities import (
    priority_options,
    priority_label,
    priority_color,
    priority_bgcolor,
    normalize_priority,
)

# ===== настройки =====
DAY_START = 0
DAY_END   = 23

ROW_MIN_H        = 36          # минимальная высота строки часа
DAY_COL_W        = 160
HOURS_COL_W      = 76
SIDE_PANEL_W     = 240
HEADER_H         = 54

CHIP_EST_H       = 26          # ожидаемая высота «чипа»
CELL_VPAD        = 8
CHIPS_SPACING    = 4

IMPORT_NEW_GCAL = True

DIALOG_WIDTH_NARROW = 460
DIALOG_WIDTH_WIDE   = 680

def _c(name: str, default: str):
    try:
        return getattr(ft.Colors, name)
    except Exception:
        return default

CLR_OUTLINE  = _c("OUTLINE_VARIANT",    "#E5E7EB")
CLR_SURFVAR  = _c("SURFACE_VARIANT",    "#F1F5F9")
CLR_TEXTSUB  = _c("ON_SURFACE_VARIANT", "#6B7280")
CLR_TODAY_BG = "#EEF2FF"
CLR_NOW_LINE = "#EF4444"
CLR_CHIP     = "#E0E7FF"
CLR_CHIP_TXT = "#1F2937"
CLR_UNS_BG   = "#FFF59D"
CLR_BACKDROP = "#000000"  # для клика-вне

NOW_ANCHOR_KEY = "now-anchor"


class CalendarPage:
    """
    - Один тип сущности: задача.
    - Ячейки часа растягиваются по содержимому.
    - Вертикальный скролл только у тела; шапка закреплена.
    - Горизонтальный скролл синхронный (шапка↔тело), левый столбец времени закреплён.
    - ESC и клик мимо окна закрывают диалог. Никаких «призраков» в overlay.
    """

    def __init__(self, app):
        self.app = app
        self.svc = TaskService()
        self._priority_options = [ft.dropdown.Option(key, label) for key, label in priority_options().items()]

        self.week_start: date = self._monday_of(date.today())

        # индекс задач: (day_idx, hour) -> [task dicts]
        self.idx: Dict[Tuple[int, int], List[dict]] = {}
        # рассчитанные высоты строк по каждому часу
        self.row_h: Dict[int, int] = {}

        # DnD
        self.current_drag_task_id: Optional[int] = None

        # автопрокрутка к «сейчас» после построения
        self._need_scroll_now = True

        # ссылки для синхронизации скролла
        self._hrow_header_ref: ft.Ref[ft.Row] = ft.Ref[ft.Row]()
        self._hrow_body_ref: ft.Ref[ft.Row]   = ft.Ref[ft.Row]()
        self._vcol_ref: ft.Ref[ft.Column]     = ft.Ref[ft.Column]()

        # защита от петель при синхронизации скролла
        self._syncing_hscroll = False

        # текущая подложка (чтобы клик-вне закрывал окно и не оставался «призрак»)
        self._backdrop: Optional[ft.Control] = None

        # ---------- Шапка экрана ----------
        self.title_text = ft.Text("", size=24, weight=ft.FontWeight.BOLD)
        self.home_btn   = ft.IconButton(icon=ft.Icons.HOME,          tooltip="Текущая неделя",  on_click=lambda e: self.go_home())
        self.prev_btn   = ft.IconButton(icon=ft.Icons.CHEVRON_LEFT,  tooltip="Назад на неделю", on_click=lambda e: self.shift_week(-1))
        self.next_btn   = ft.IconButton(icon=ft.Icons.CHEVRON_RIGHT, tooltip="Вперёд на неделю",on_click=lambda e: self.shift_week(1))

        header = ft.Row(
            controls=[ft.Row([self.prev_btn, self.home_btn, self.next_btn], spacing=6),
                      self.title_text,
                      ft.Container()],  # пустой правый край
            alignment=ft.MainAxisAlignment.SPACE_BETWEEN,
        )

        # ---------- Без даты ----------
        self.unscheduled_list = ft.ListView(expand=True, spacing=6)
        self.side_panel = ft.Container(
            width=SIDE_PANEL_W,
            content=ft.Column(
                [ft.Text("Без даты", size=16, weight=ft.FontWeight.W_600),
                 ft.Divider(height=1),
                 self.unscheduled_list],
                expand=True, spacing=8),
            padding=10,
            border=ft.border.all(0.5, CLR_OUTLINE),
            border_radius=8,
        )

        # ---------- Область сетки ----------
        self.grid = ft.Container(expand=True)

        self.view = ft.Container(
            content=ft.Column(
                [header, ft.Divider(height=1), ft.Row([self.side_panel, self.grid], expand=True, spacing=12)],
                spacing=12, expand=True),
            expand=True, padding=20,
        )

        self.load()

    # ===== публичное: вызывать из бокового меню =====
    def activate_from_menu(self):
        self._close_any_dialog()
        self.week_start = self._monday_of(date.today())
        self._need_scroll_now = True
        self.load()

    # ===== Диалоги через overlay (как у тебя раньше) =====
    def _cleanup_backdrop(self):
        try:
            if self._backdrop and self._backdrop in self.app.page.overlay:
                self.app.page.overlay.remove(self._backdrop)
        except Exception:
            pass
        self._backdrop = None

    def _open_dialog(self, dlg: ft.AlertDialog):
        self._cleanup_backdrop()
        self._backdrop = ft.Container(
            expand=True,
            bgcolor=ft.Colors.with_opacity(0.001, CLR_BACKDROP),
            on_click=lambda e, d=dlg: self._close_dialog(d),
            data="backdrop",   # <<< метка, чтобы потом удалить
        )
        self.app.page.overlay.append(self._backdrop)

        dlg.modal = False
        dlg.on_dismiss = lambda e, d=dlg: self._close_dialog(d)
        if dlg not in self.app.page.overlay:
            self.app.page.overlay.append(dlg)
        dlg.open = True
        self.app.page.update()
        self._sweep_overlay()  # <<< сразу подчистить

    def _close_dialog(self, dlg: ft.AlertDialog | None):
        if not dlg:
            return
        cleanup_meta = getattr(dlg, "data", None)
        if isinstance(cleanup_meta, dict):
            fn = cleanup_meta.get("on_close")
            if callable(fn):
                try:
                    fn()
                finally:
                    cleanup_meta["on_close"] = None
        try:
            dlg.open = False
        except Exception:
            pass
        try:
            if dlg in self.app.page.overlay:
                self.app.page.overlay.remove(dlg)
        except Exception:
            pass
        self._cleanup_backdrop()
        self._sweep_overlay()
        self.app.page.update()
        self.app.cleanup_overlays()

    def _close_any_dialog(self):
        # на всякий случай закрыть всё
        try:
            overlays = list(self.app.page.overlay)
        except Exception:
            overlays = []

        for ctrl in overlays:
            if isinstance(ctrl, ft.AlertDialog):
                self._close_dialog(ctrl)

        self._cleanup_backdrop()
        self._sweep_overlay()
        self.app.page.update()
        self.app.cleanup_overlays()
    def _delete_task(self, task_id: int):
        t = self.svc.get(task_id)
        if not t:
            return self._toast("Задача не найдена")
        # удаляем событие в Google, если привязано
        if getattr(t, "gcal_event_id", None):
            try:
                self.app.gcal.delete_event_by_id(t.gcal_event_id)
            except Exception:
                pass
        self.svc.delete(task_id)
        self.load()
        self._toast("Удалено")


    # ===== Даты / навигация =====
    def _monday_of(self, d: date) -> date:
        return d - timedelta(days=d.weekday())

    def _week_days(self) -> List[date]:
        return [self.week_start + timedelta(days=i) for i in range(7)]

    def go_home(self):
        self._close_any_dialog()
        self.week_start = self._monday_of(date.today())
        self._need_scroll_now = True
        self.load()

    def shift_week(self, delta_weeks: int):
        self._close_any_dialog()
        base = self.week_start or self._monday_of(date.today())
        self.week_start = self._monday_of(base + timedelta(days=7 * delta_weeks))
        self._need_scroll_now = True
        self.load()
    
    def _sweep_overlay(self):
        # убираем закрытые диалоги и осиротевшие подложки
        ov = self.app.page.overlay or []
        changed = False
        for c in list(ov):
            if isinstance(c, ft.AlertDialog) and not getattr(c, "open", False):
                try:
                    ov.remove(c); changed = True
                except Exception:
                    pass
            elif isinstance(c, ft.Container) and getattr(c, "data", None) == "backdrop":
                # оставляем подложку только если есть открытый AlertDialog
                if not any(getattr(d, "open", False) for d in ov if isinstance(d, ft.AlertDialog)):
                    try:
                        ov.remove(c); changed = True
                    except Exception:
                        pass
        if changed:
            self.app.page.update()
            self.app.cleanup_overlays()

    # ===== Загрузка =====
    def load(self):
        ws = self.week_start
        we = ws + timedelta(days=6)
        self.title_text.value = f"Неделя {ws.strftime('%d.%m')} — {we.strftime('%d.%m.%Y')}"
        self._sync_from_google(ws, we)


        # индекс задач за неделю
        self.idx.clear()
        for i in range(7):
            d = ws + timedelta(days=i)
            for t in self.svc.list_for_day(d):
                st = getattr(t, "start", None)
                if not isinstance(st, datetime):
                    continue
                dur = getattr(t, "duration_minutes", None) or 30
                di = (st.date() - ws).days
                if 0 <= di < 7:
                    self.idx.setdefault((di, st.hour), []).append(
                        {
                            "title": t.title,
                            "task_id": t.id,
                            "duration": dur,
                            "gcal_event_id": getattr(t, "gcal_event_id", None),
                            "priority": getattr(t, "priority", 0),
                        }
                    )

        # высоты строк
        self.row_h = {}
        for h in range(DAY_START, DAY_END + 1):
            max_n = 0
            for di in range(7):
                max_n = max(max_n, len(self.idx.get((di, h), [])))
            height = ROW_MIN_H if max_n <= 0 else max(ROW_MIN_H, CELL_VPAD + max_n * CHIP_EST_H + (max_n - 1) * CHIPS_SPACING)
            self.row_h[h] = height

        for key, tasks in self.idx.items():
            tasks.sort(key=lambda item: (-item.get("priority", 0), item.get("title", "").lower()))

        self._build_unscheduled()
        self.grid.content = self._build_week_grid()
        self.app.page.update()

        if self._need_scroll_now:
            self._need_scroll_now = False
            self._scroll_to_now()
        self.app.cleanup_overlays()
    def _sync_from_google(self, ws: date, we: date):
        """Подтягивает изменения из Google за окно недели (с небольшим буфером)
        и обновляет/создаёт/отвязывает локальные задачи.
        """
        g = getattr(self.app, "gcal", None)
        if not g or not getattr(g, "calendar_id", None):
            return

        # Берём окно чуть шире текущей недели
        rng_start = ws - timedelta(days=3)
        rng_end   = we + timedelta(days=3)

        try:
            # ожидаем, что list_range(start_dt, end_dt, show_deleted=True) у тебя есть
            events = g.list_range(
                datetime(rng_start.year, rng_start.month, rng_start.day, 0, 0, 0),
                datetime(rng_end.year, rng_end.month, rng_end.day, 23, 59, 59),
                show_deleted=True  # важно для отслеживания удалений
            )
        except Exception as ex:
            self._toast(f"Google sync: {ex}")
            return

        # --- утилита парсинга дат ---
        def _parse_ev_datetime(s: str | None):
            if not s:
                return None
            try:
                return datetime.fromisoformat(s.replace("Z", "+00:00"))
            except Exception:
                return None

        # карты по id событий
        ev_map = {}
        for ev in events or []:
            eid = ev.get("id")
            if not eid:
                continue
            status = ev.get("status", "confirmed")
            if status == "cancelled":
                ev_map[eid] = {"deleted": True}
                continue

            st = ev.get("start") or {}
            en = ev.get("end") or {}

            # all-day: Google присылает "date" вместо "dateTime"
            if "dateTime" in st and "dateTime" in en:
                dt_start = _parse_ev_datetime(st.get("dateTime"))
                dt_end   = _parse_ev_datetime(en.get("dateTime"))
                dur = None
                if dt_start and dt_end:
                    dur = int((dt_end - dt_start).total_seconds() // 60)
                ev_map[eid] = {
                    "title": ev.get("summary") or "",
                    "start": dt_start,
                    "duration": dur,
                    "allday": False,
                }
            else:
                # all-day -> ставим дату без времени (твой Today/Календарь понимают это как "без времени")
                try:
                    d = date.fromisoformat((st.get("date") or "").strip())
                    dt_start = datetime(d.year, d.month, d.day)
                except Exception:
                    dt_start = None
                ev_map[eid] = {
                    "title": ev.get("summary") or "",
                    "start": dt_start,
                    "duration": None,
                    "allday": True,
                }

        # --- Собираем локальные связанные задачи в нашем окне + «без даты» ---
        linked_tasks: list = []
        for i in range((rng_end - rng_start).days + 1):
            d = rng_start + timedelta(days=i)
            for t in self.svc.list_for_day(d):
                if getattr(t, "gcal_event_id", None):
                    linked_tasks.append(t)
        for t in self.svc.list_unscheduled():
            if getattr(t, "gcal_event_id", None):
                linked_tasks.append(t)

        # --- Обновляем связанные задачи по данным из Google ---
        seen_event_ids = set()
        for t in linked_tasks:
            eid = getattr(t, "gcal_event_id", None)
            info = ev_map.get(eid)
            if not eid:
                continue
            seen_event_ids.add(eid)

            # Событие удалили со стороны Google
            if not info or info.get("deleted"):
                try:
                    # по умолчанию — не удаляем задачу, а отвязываем и убираем расписание
                    self.svc.update(t.id, start=None)
                    self.svc.set_event_id(t.id, None)
                except Exception:
                    pass
                continue

            # Обновления полей
            upd = {}
            if (t.title or "") != (info["title"] or ""):
                upd["title"] = info["title"] or ""

            if info["allday"]:
                # день без времени
                if not t.start or t.start.date() != info["start"].date() or (t.start.hour != 0 or t.start.minute != 0):
                    upd["start"] = datetime(info["start"].year, info["start"].month, info["start"].day)
                if getattr(t, "duration_minutes", None) is not None:
                    upd["duration_minutes"] = None
            else:
                if not t.start or t.start != info["start"]:
                    upd["start"] = info["start"]
                if getattr(t, "duration_minutes", None) != info["duration"]:
                    upd["duration_minutes"] = info["duration"]

            if upd:
                try:
                    self.svc.update(t.id, **upd)
                except Exception:
                    pass

        # --- (опционально) импорт новых событий как задач ---
        if IMPORT_NEW_GCAL:
            for eid, info in ev_map.items():
                if eid in seen_event_ids:
                    continue
                if info.get("deleted"):
                    continue
                try:
                    # создаём новую задачу, сразу привязываем eid
                    new_task = self.svc.add(
                        title=info.get("title") or "(без названия)",
                        start=info.get("start"),
                        duration_minutes=info.get("duration"),
                    )
                    self.svc.set_event_id(new_task.id, eid)
                except Exception:
                    pass


    # ===== Без даты =====
    def _build_unscheduled(self):
        self.unscheduled_list.controls.clear()
        for t in self.svc.list_unscheduled():
            badge = self._priority_badge(t.priority)
            chip = ft.Container(
                content=ft.Row(
                    [badge, ft.Text(t.title, size=12, no_wrap=True, overflow=ft.TextOverflow.ELLIPSIS, color=CLR_CHIP_TXT)],
                    spacing=8,
                    vertical_alignment=ft.CrossAxisAlignment.CENTER,
                ),
                padding=8,
                bgcolor=priority_bgcolor(t.priority) if t.priority else CLR_UNS_BG,
                border=ft.border.all(0.5, CLR_OUTLINE), border_radius=8,
                width=SIDE_PANEL_W - 20,
            )
            drag = ft.Draggable(
                group="task",
                data=str(t.id),
                on_drag_start=lambda e, tid=t.id: self._remember_drag(tid),
                content=chip,
                content_feedback=ft.Container(
                    content=ft.Text(t.title, size=12),
                    padding=8, bgcolor="#ffffff", border_radius=6,
                    border=ft.border.all(0.5, CLR_OUTLINE),
                ),
            )
            self.unscheduled_list.controls.append(drag)

    def _remember_drag(self, task_id: int):
        self.current_drag_task_id = task_id
        self.app.page.update()

    # ===== Сетка =====
    def _build_week_grid(self) -> ft.Control:
        days = self._week_days()
        today = date.today()
        now = datetime.now()

        # --- Шапка дней (в собственном viewport) ---
        header_cells: List[ft.Control] = []
        for i, d in enumerate(days):
            header_cells.append(
                ft.Container(
                    width=DAY_COL_W, height=HEADER_H,
                    content=ft.Column(
                        [ft.Text(d.strftime("%a"), size=14, weight=ft.FontWeight.W_600),
                         ft.Text(d.strftime("%d.%m"), size=12, color=CLR_TEXTSUB)],
                        spacing=2, horizontal_alignment=ft.CrossAxisAlignment.CENTER),
                    alignment=ft.alignment.center,
                    bgcolor=CLR_TODAY_BG if d == today else None,
                    border=ft.border.only(right=ft.BorderSide(0.5, CLR_OUTLINE)) if i < 6 else None,
                )
            )
        hrow_header = ft.Row(controls=header_cells, spacing=0, ref=self._hrow_header_ref, scroll=ft.ScrollMode.ALWAYS)
        header_viewport = ft.Container(  # ограничиваем ширину, чтобы работал скролл
            height=HEADER_H, expand=True, content=hrow_header, clip_behavior=ft.ClipBehavior.HARD_EDGE
        )

        # --- Левый столбец часов (закреплён) ---
        hours_controls: List[ft.Control] = []
        for h in range(DAY_START, DAY_END + 1):
            hours_controls.append(
                ft.Container(
                    content=ft.Text(f"{h:02d}:00", size=12, color=CLR_TEXTSUB),
                    width=HOURS_COL_W, height=self.row_h[h],
                    alignment=ft.alignment.center_right,
                    padding=ft.padding.only(right=8),
                    border=ft.border.only(bottom=ft.BorderSide(0.6, CLR_OUTLINE)),
                )
            )
        hours_col = ft.Column(controls=hours_controls, spacing=0, width=HOURS_COL_W)

        # --- Колонки дней (тело), тоже в viewport по X ---
        day_cols: List[ft.Control] = []
        for di, d in enumerate(days):
            is_today_col = (d == today)
            col_rows: List[ft.Control] = []
            for h in range(DAY_START, DAY_END + 1):
                tasks = self.idx.get((di, h), [])
                is_now = is_today_col and (h == now.hour)
                slot = self._slot_body(tasks, is_now, d, h)
                drop = ft.DragTarget(group="task", content=slot,
                                     on_accept=lambda e, _d=d, _h=h: self._on_drop_accept(_d, _h, e))
                cell = ft.Container(
                    content=drop, width=DAY_COL_W, height=self.row_h[h],
                    bgcolor=CLR_TODAY_BG if is_today_col else None,
                    border=ft.border.only(
                        right=ft.BorderSide(0.5, CLR_OUTLINE) if di < 6 else None,
                        bottom=ft.BorderSide(0.6, CLR_OUTLINE),
                    ),
                )
                col_rows.append(cell)
            day_cols.append(ft.Container(content=ft.Column(col_rows, spacing=0), width=DAY_COL_W))

        hrow_body = ft.Row(controls=day_cols, spacing=0, ref=self._hrow_body_ref, scroll=ft.ScrollMode.ALWAYS)
        body_viewport = ft.Container(expand=True, content=hrow_body, clip_behavior=ft.ClipBehavior.HARD_EDGE)

        # --- синхронизация скролла шапки и тела ---
        hrow_header.on_scroll = self._on_header_hscroll
        hrow_body.on_scroll   = self._on_body_hscroll

        # --- вертикальный скролл: часы слева (фикс), тело справа (viewport по X) ---
        vscroll_body = ft.Column(
            controls=[ft.Row([hours_col, body_viewport], spacing=0)],
            spacing=0, expand=True, scroll=ft.ScrollMode.ALWAYS, ref=self._vcol_ref
        )

        # --- финальная сборка ---
        top_header = ft.Row(
            controls=[ft.Container(width=HOURS_COL_W, height=HEADER_H), header_viewport],
            spacing=0,
        )

        return ft.Container(
            content=ft.Column(
                controls=[top_header, ft.Divider(height=1, color=CLR_OUTLINE), vscroll_body],
                spacing=0, expand=True),
            expand=True,
            border_radius=8,
            border=ft.border.all(0.5, CLR_OUTLINE),
            padding=8,
            bgcolor="#fff",
        )

    # синхронизация горизонтального скролла (без «рывков»)
    def _on_body_hscroll(self, e: ft.OnScrollEvent):
        if self._syncing_hscroll:
            return
        try:
            self._syncing_hscroll = True
            hdr = self._hrow_header_ref.current
            if hdr:
                hdr.scroll_to(offset=e.pixels, duration=0)
        finally:
            self._syncing_hscroll = False

    def _on_header_hscroll(self, e: ft.OnScrollEvent):
        if self._syncing_hscroll:
            return
        try:
            self._syncing_hscroll = True
            body = self._hrow_body_ref.current
            if body:
                body.scroll_to(offset=e.pixels, duration=0)
        finally:
            self._syncing_hscroll = False

    def _slot_body(self, tasks: List[dict], is_now_hour: bool, day: date, hour: int) -> ft.Control:
        chips: List[ft.Control] = []
        if is_now_hour:
            chips.append(ft.Container(key=NOW_ANCHOR_KEY, height=1, width=1))
            chips.append(ft.Container(height=2, bgcolor=CLR_NOW_LINE))

        if tasks:
            for t in tasks:
                chips.append(self._build_chip(t, day, hour))
        else:
            # кликабельная площадь заполняет весь слот по высоте
            chips.append(
                ft.Container(
                    on_click=lambda e, d=day, h=hour: self.open_quick_add(d, h),
                    width=DAY_COL_W,
                    height=max(8, self.row_h.get(hour, ROW_MIN_H) - 8),
                )
            )

        return ft.Container(
            content=ft.Column(chips, spacing=CHIPS_SPACING),
            padding=ft.padding.only(left=6, right=6, top=4, bottom=4),
            width=DAY_COL_W, expand=True,
            bgcolor=CLR_SURFVAR if tasks else None,
        )

    def _build_chip(self, t: dict, day: date, hour: int) -> ft.Control:
        title = t.get("title", "")
        tid = t.get("task_id")
        dur = t.get("duration", 30)
        priority = t.get("priority", 0)

        chip_body = ft.Container(
            content=ft.Row(
                [
                    self._priority_badge(priority),
                    ft.Text(
                        title,
                        size=11,
                        color=CLR_CHIP_TXT,
                        no_wrap=True,
                        overflow=ft.TextOverflow.ELLIPSIS,
                    ),
                ],
                spacing=6,
                vertical_alignment=ft.CrossAxisAlignment.CENTER,
            ),
            bgcolor=priority_bgcolor(priority) if priority else CLR_CHIP,
            border=ft.border.all(0.5, CLR_OUTLINE),
            border_radius=8,
            padding=6, width=DAY_COL_W-12,
        )
        gd = ft.GestureDetector(
            content=chip_body,
            on_tap=lambda e, _tid=tid: self._open_edit_dialog(_tid, title, dur),
            on_secondary_tap=lambda e, _tid=tid, _title=title, _dur=dur, _d=day, _h=hour:
                self._open_chip_menu(_tid, _title, _dur, _d, _h),
        )
        return ft.Draggable(
            group="task",
            data=str(tid),
            on_drag_start=lambda e, t_id=tid: self._remember_drag(t_id),
            content=gd,
            content_feedback=ft.Container(
                content=ft.Text(title, size=12),
                padding=8, bgcolor="#ffffff", border_radius=6, border=ft.border.all(0.5, CLR_OUTLINE),
            ),
        )

    # ===== Контекстное меню чипа =====
    def _open_chip_menu(self, task_id: int, title: str, duration: int, day: date, hour: int):
        dlg = None

        def close(_=None):
            self._close_dialog(dlg)
            self._sweep_overlay()  

        def act_edit(_):
            close(); self._open_edit_dialog(task_id, title, duration)

        def act_move(_):
            close(); self._schedule_task(task_id, day, hour)

        def act_snooze30(_):
            close(); self._snooze_minutes(task_id, day, hour, duration, 30)

        def act_evening(_):
            close(); self._snooze_evening(task_id)

        def act_tomorrow(_):
            close(); self._snooze_tomorrow(task_id)

        def act_delete(_):
            close(); self._delete_task(task_id)

        content = ft.Column(
            controls=[
                ft.TextButton("Редактировать", on_click=act_edit),
                ft.TextButton("Перенести…", on_click=act_move),
                ft.Divider(height=1),
                ft.TextButton("Snooze +30 мин", on_click=act_snooze30),
                ft.TextButton("Сегодня вечером", on_click=act_evening),
                ft.TextButton("Завтра 10:00", on_click=act_tomorrow),
                ft.Divider(height=1),
                ft.TextButton("Удалить", icon=ft.Icons.DELETE_OUTLINE, on_click=act_delete),
            ],
            tight=True, spacing=4, width=240,
        )
        dlg = ft.AlertDialog(modal=False, title=ft.Text(title), content=content)
        self._open_dialog(dlg)

    # ===== DnD =====
    def _on_drop_accept(self, day: date, hour: int, e):
        task_id = self.current_drag_task_id
        if task_id is None:
            s = str(e.data or "").strip()
            if s.isdigit():
                task_id = int(s)
            else:
                try:
                    payload = json.loads(s)
                    if isinstance(payload, dict) and "task_id" in payload:
                        task_id = int(payload["task_id"])
                except Exception:
                    task_id = None
        self.current_drag_task_id = None
        if task_id is None:
            return self._toast("Не удалось определить задачу")
        self._schedule_task(task_id, day, hour)

    # ===== Планирование и быстрый блок =====
    def _schedule_task(self, task_id: int, day: date, hour: int):
        start_dt = datetime(day.year, day.month, day.day, hour, 0, 0)
        task = self.svc.get(task_id)
        if not task:
            return self._toast("Задача не найдена")
        dur_value = task.duration_minutes or 30
        dur_tf = ft.TextField(label="Длительность, мин", value=str(dur_value), width=140)
        priority_dd = ft.Dropdown(
            label="Приоритет",
            width=220,
            value=str(getattr(task, "priority", 0)),
            options=self._priority_options,
        )
        dlg = None

        def on_save(_):
            try:
                duration = int(dur_tf.value)
                if duration <= 0:
                    raise ValueError
            except Exception:
                return self._toast("Длительность должна быть > 0")

            priority = normalize_priority(priority_dd.value)

            t = self.svc.update(
                task_id,
                start=start_dt,
                duration_minutes=duration,
                priority=priority,
            )
            try:
                if t and getattr(t, "gcal_event_id", None):
                    self.app.gcal.update_event_for_task(t.gcal_event_id, t, start_dt, duration)
                elif t:
                    ev = self.app.gcal.create_event_for_task(t, start_dt, duration)
                    self.svc.set_event_id(task_id, ev["id"])
            except Exception as ex:
                self._toast(f"Google недоступен: {ex}")

            self._close_dialog(dlg)
            self._sweep_overlay()
            self.load()

        def on_cancel(_):
            self._close_dialog(dlg)
            self._sweep_overlay()

        dlg = ft.AlertDialog(
            modal=False,
            inset_padding=ft.padding.all(16),
            content_padding=ft.padding.all(12),
            title=ft.Text(f"Запланировать — {start_dt.strftime('%a, %d.%m %H:00')}"),
            content=ft.Container(
                width=DIALOG_WIDTH_NARROW,
                content=ft.Column([dur_tf, priority_dd], spacing=12, tight=True),
            ),
            actions=[
                ft.TextButton("Отмена", on_click=on_cancel),
                ft.FilledButton("Сохранить", icon=ft.Icons.SAVE, on_click=on_save),
            ],
            actions_alignment=ft.MainAxisAlignment.END,
        )

        self._open_dialog(dlg)

    def open_quick_add(self, day: date, hour: int):
        start_dt = datetime(day.year, day.month, day.day, hour, 0, 0)
        title_tf = ft.TextField(label="Название", width=DIALOG_WIDTH_NARROW - 40)
        dur_tf = ft.TextField(label="Длительность, мин", value="30", width=140)
        priority_dd = ft.Dropdown(
            label="Приоритет",
            width=180,
            value=str(0),
            options=self._priority_options,
        )
        dlg = None

        def on_save(_):
            title = (title_tf.value or "").strip()
            if not title:
                return self._toast("Введите название")
            try:
                duration = int(dur_tf.value)
                if duration <= 0:
                    raise ValueError
            except Exception:
                return self._toast("Длительность должна быть > 0")
            priority = normalize_priority(priority_dd.value)

            task = self.svc.add(title=title, start=start_dt, duration_minutes=duration, priority=priority)
            try:
                ev = self.app.gcal.create_event_for_task(task, start_dt, duration)
                self.svc.set_event_id(task.id, ev["id"])
                self._toast("Создано и в календаре")
            except Exception as ex:
                self._toast(f"Создано локально (Google недоступен): {ex}")

            self._close_dialog(dlg)
            self._sweep_overlay()
            self.load()

        def on_cancel(_):
            self._close_dialog(dlg)
            self._sweep_overlay()

        dlg = ft.AlertDialog(
            modal=False,
            inset_padding=ft.padding.all(16),
            content_padding=ft.padding.all(12),
            title=ft.Text(f"Быстрый блок — {start_dt.strftime('%a, %d.%m %H:00')}"),
            content=ft.Container(
                width=DIALOG_WIDTH_NARROW,
                content=ft.Column([title_tf, dur_tf, priority_dd], spacing=12, tight=True),
            ),
            actions=[
                ft.TextButton("Отмена", on_click=on_cancel),
                ft.FilledButton("Сохранить", icon=ft.Icons.SAVE, on_click=on_save),
            ],
            actions_alignment=ft.MainAxisAlignment.END,
        )
        self._open_dialog(dlg)

    # ===== Редактирование / Snooze / Удаление =====
    # ui/pages/calendar.py  (внутри класса CalendarPage)
    def _open_edit_dialog(
        self,
        task_id: int,
        current_title: str | None = None,
        current_duration: int | None = None,
    ):
        # --- берём актуальные данные задачи ---
        t = None
        try:
            t = self.svc.get(task_id)
        except Exception:
            pass
        if t is None:
            return self._toast("Задача не найдена")

        title_init = current_title if current_title is not None else (t.title or "")
        dur_init   = current_duration if current_duration is not None else (t.duration_minutes or 30)
        start_init = getattr(t, "start", None)

        date_str = start_init.strftime("%d.%m.%Y") if isinstance(start_init, datetime) else ""
        time_str = start_init.strftime("%H:%M")     if isinstance(start_init, datetime) else ""

        # --- поля формы (без expand) ---
        DATE_W, TIME_W, DUR_W = 140, 100, 120

        title_tf = ft.TextField(label="Название", value=title_init, width=DIALOG_WIDTH_WIDE - 80)
        date_tf  = ft.TextField(label="Дата",  value=date_str, width=DATE_W, read_only=True)
        time_tf  = ft.TextField(label="Время", value=time_str, width=TIME_W, read_only=True)
        dur_tf   = ft.TextField(label="Длительность, мин", value=str(dur_init), width=DUR_W)
        priority_dd = ft.Dropdown(
            label="Приоритет",
            width=200,
            value=str(getattr(t, "priority", 0)),
            options=self._priority_options,
        )

        # заметки (авто-увеличение по числу строк)
        notes_tf = ft.TextField(
            label="Заметки",
            value=(t.notes or ""),
            multiline=True,
            min_lines=3,
            max_lines=6,
        )
        def _autogrow(_=None):
            s = notes_tf.value or ""
            # считаем количество визуальных строк (по \n)
            lines = max(3, min(12, s.count("\n") + 1))
            if notes_tf.max_lines != lines:
                notes_tf.max_lines = lines
                self.app.page.update()
        notes_tf.on_change = _autogrow
        _autogrow()  # подстроиться под начальный текст

        # --- пикеры ---
        dp = ft.DatePicker(
            first_date=date(2000, 1, 1),
            last_date=date(2100, 12, 31),
            on_change=lambda e: self._set_tf_date(date_tf, e.data or e.control.value),
            on_dismiss=lambda e: self._set_tf_date(date_tf, e.control.value),
        )
        tp = self._new_time_picker()
        for p in (dp, tp):
            if p not in self.app.page.overlay:
                self.app.page.overlay.append(p)

        date_btn = ft.IconButton(
            icon=ft.Icons.CALENDAR_MONTH,
            tooltip="Выбрать дату",
            icon_size=18,
            on_click=lambda e, _dp=dp: self.app.page.open(_dp),
        )
        time_btn = ft.IconButton(
            icon=ft.Icons.SCHEDULE,
            tooltip="Выбрать время",
            icon_size=18,
            on_click=lambda e, _tp=tp: self._open_time_picker(_tp, time_tf),
        )

        # --- сохранение / отмена ---
        dlg = None

        def _remove_pickers():
            for ctrl in (dp, tp):
                try:
                    ctrl.open = False
                except Exception:
                    pass
                try:
                    if ctrl in self.app.page.overlay:
                        self.app.page.overlay.remove(ctrl)
                except Exception:
                    pass

        def on_save(_):
            new_title = (title_tf.value or "").strip()
            if not new_title:
                return self._toast("Введите название")

            if date_tf.value and self._parse_date_tf(date_tf.value) is None:
                return self._toast("Неверный формат даты. Пример: 10.10.2025")
            if time_tf.value and self._parse_time_tf(time_tf.value) is None:
                return self._toast("Неверный формат времени. Пример: 09:30")

            new_start = self._combine_dt(date_tf.value, time_tf.value)
            try:
                new_dur = int(dur_tf.value) if dur_tf.value.strip() else None
            except ValueError:
                return self._toast("Длительность должна быть числом (мин)")

            updated = self.svc.update(
                task_id,
                title=new_title,
                notes=notes_tf.value,
                start=new_start,
                duration_minutes=new_dur,
                priority=normalize_priority(priority_dd.value),
            )

            # --- Google Calendar sync ---
            if new_start is not None and new_dur is not None:
                if updated.gcal_event_id:
                    try:
                        self.app.gcal.update_event_for_task(updated.gcal_event_id, updated, new_start, new_dur)
                    except Exception as e:
                        self._toast(f"Google: не удалось обновить: {e}")
                else:
                    try:
                        ev = self.app.gcal.create_event_for_task(updated, new_start, new_dur)
                        self.svc.set_event_id(task_id, ev["id"])
                    except Exception as e:
                        self._toast(f"Google: не удалось создать: {e}")
            else:
                # если дата/время/длительность очищены — удаляем привязанное событие
                if updated.gcal_event_id:
                    try:
                        self.app.gcal.delete_event_by_id(updated.gcal_event_id)
                    finally:
                        self.svc.set_event_id(task_id, None)

            _remove_pickers()
            self._close_dialog(dlg)
            self._sweep_overlay()
            self.load()
            self._toast("Сохранено")

        def on_cancel(_=None):
            _remove_pickers()
            self._close_dialog(dlg)
            self._sweep_overlay()

        # --- компактная вёрстка (без Wrap) ---
        utils_row = ft.Row(
            [date_tf, date_btn, time_tf, time_btn, dur_tf, priority_dd],
            spacing=8,
            vertical_alignment=ft.CrossAxisAlignment.END,
        )
        buttons_row = ft.Row(
            [ft.TextButton("Отмена", on_click=on_cancel),
            ft.FilledButton("Сохранить", icon=ft.Icons.SAVE, on_click=on_save)],
            alignment=ft.MainAxisAlignment.END,
        )

        dlg = ft.AlertDialog(
            modal=False,
            inset_padding=ft.padding.all(16),
            content_padding=ft.padding.all(12),
            title=ft.Text("Редактировать задачу"),
            content=ft.Container(
                width=DIALOG_WIDTH_WIDE,
                content=ft.Column(
                    [title_tf, utils_row, notes_tf, buttons_row],
                    spacing=10,
                    tight=True,
                    scroll=ft.ScrollMode.ADAPTIVE,
                ),
            ),
        )

        dlg.data = {"on_close": _remove_pickers}
        self._open_dialog(dlg)



    def _snooze_minutes(self, task_id: int, day: date, hour: int, duration: int, add_minutes: int):
        base = datetime(day.year, day.month, day.day, hour, 0, 0) + timedelta(minutes=add_minutes)
        self._reschedule(task_id, base, duration)

    def _snooze_evening(self, task_id: int):
        now = datetime.now().astimezone()
        base = now.replace(hour=19, minute=0, second=0, microsecond=0)
        if base < now:
            base = base + timedelta(days=1)
        self._reschedule(task_id, base, 30)

    def _snooze_tomorrow(self, task_id: int):
        base = (datetime.now().astimezone() + timedelta(days=1)).replace(hour=10, minute=0, second=0, microsecond=0)
        self._reschedule(task_id, base, 30)

    def _reschedule(self, task_id: int, start_dt: datetime, duration: int):
        t = self.svc.update(task_id, start=start_dt, duration_minutes=duration)
        try:
            if t and getattr(t, "gcal_event_id", None):
                self.app.gcal.update_event_for_task(t.gcal_event_id, t, start_dt, duration)
            elif t:
                ev = self.app.gcal.create_event_for_task(t, start_dt, duration)
                self.svc.set_event_id(task_id, ev["id"])
        except Exception as ex:
            self._toast(f"Google недоступен: {ex}")
        self.load()

    # ===== автопрокрутка к сегодняшнему дню и текущему часу =====
    def _scroll_to_now(self):
        # вертикаль
        try:
            now = datetime.now()
            top_offset = 0
            for h in range(DAY_START, min(now.hour, DAY_END + 1)):
                top_offset += self.row_h.get(h, 0)
            if self._vcol_ref.current:
                self._vcol_ref.current.scroll_to(offset=top_offset, duration=300)
        except Exception:
            pass

        # горизонталь
        try:
            day_idx = (date.today() - self.week_start).days
            if 0 <= day_idx < 7:
                offset_x = DAY_COL_W * day_idx
                if self._hrow_body_ref.current:
                    self._hrow_body_ref.current.scroll_to(offset=offset_x, duration=300)
                if self._hrow_header_ref.current:
                    self._hrow_header_ref.current.scroll_to(offset=offset_x, duration=300)
        except Exception:
            pass

    # публичная обёртка, чтобы дергать из AppShell    
    def scroll_to_now(self):
        self._scroll_to_now()

    # ===== Вспомогательное для форм =====
    def _new_time_picker(self) -> ft.TimePicker:
        picker = ft.TimePicker(help_text="Выберите время")
        picker.on_change = lambda e, _picker=picker: self._time_picker_on_change(_picker, e)
        picker.on_dismiss = lambda e, _picker=picker: self._time_picker_on_dismiss(_picker, e)
        return picker

    def _open_time_picker(self, picker: ft.TimePicker, tf: ft.TextField):
        prev = tf.value
        parsed = self._parse_time_tf(tf.value)
        if parsed:
            base_time = dt_time(parsed[0], parsed[1])
        else:
            now = datetime.now()
            base_time = dt_time(now.hour, now.minute)
        try:
            picker.value = base_time
        except Exception:
            pass
        picker.data = {"tf": tf, "prev": prev, "applied": False}
        if picker not in self.app.page.overlay:
            self.app.page.overlay.append(picker)
        self.app.page.open(picker)

    def _time_picker_on_change(self, picker: ft.TimePicker, e: ft.ControlEvent):
        data = picker.data or {}
        tf = data.get("tf")
        if not tf:
            return
        value = e.data or picker.value
        if value:
            self._set_tf_time(tf, value)
            data["applied"] = True
            picker.data = data

    def _time_picker_on_dismiss(self, picker: ft.TimePicker, e: ft.ControlEvent):
        data = picker.data or {}
        tf = data.get("tf")
        if not tf:
            picker.data = None
            return
        value = e.data
        if value:
            self._set_tf_time(tf, value)
            data["applied"] = True
        elif not data.get("applied"):
            tf.value = data.get("prev", tf.value)
            self.app.page.update()
        picker.data = None

    def _set_tf_date(self, tf: ft.TextField, value):
        from datetime import date as _date, datetime as _dt

        v = value
        if isinstance(v, _date):
            tf.value = v.strftime("%d.%m.%Y")
        elif isinstance(v, str) and v.strip():
            s = v.strip()
            try:
                tf.value = _dt.strptime(s, "%Y-%m-%d").strftime("%d.%m.%Y")
            except ValueError:
                if "T" in s:
                    try:
                        tf.value = _dt.strptime(s.split("T")[0], "%Y-%m-%d").strftime("%d.%m.%Y")
                    except ValueError:
                        pass
                else:
                    try:
                        _dt.strptime(s, "%d.%m.%Y")
                        tf.value = s
                    except ValueError:
                        return
        self.app.page.update()

    def _set_tf_time(self, tf: ft.TextField, value):
        if value in (None, ""):
            return
        try:
            tf.value = value.strftime("%H:%M")
            self.app.page.update()
            return
        except Exception:
            pass

        s = str(value or "").strip()
        m = re.match(r"^(\d{1,2}):(\d{2})(?::(\d{2}))?$", s)
        if m:
            h = int(m.group(1))
            mm = int(m.group(2))
            if 0 <= h <= 23 and 0 <= mm <= 59:
                tf.value = f"{h:02d}:{mm:02d}"
        self.app.page.update()

    def _parse_date_tf(self, s: str):
        s = (s or "").strip()
        m = re.match(r"^\s*(\d{1,2})\.(\d{1,2})\.(\d{4})\s*$", s)
        if not m:
            return None
        d, mth, y = int(m.group(1)), int(m.group(2)), int(m.group(3))
        try:
            return date(y, mth, d)
        except ValueError:
            return None

    def _parse_time_tf(self, s: str):
        s = (s or "").strip()
        m = re.match(r"^\s*(\d{1,2}):(\d{2})(?::\d{2})?\s*$", s)
        if not m:
            return None
        h, minute = int(m.group(1)), int(m.group(2))
        if 0 <= h <= 23 and 0 <= minute <= 59:
            return h, minute
        return None

    def _combine_dt(self, date_str: str, time_str: str):
        d = self._parse_date_tf(date_str)
        t = self._parse_time_tf(time_str)
        if d and t:
            return datetime(d.year, d.month, d.day, t[0], t[1])
        if d and not t:
            return datetime(d.year, d.month, d.day)
        if t and not d:
            today = date.today()
            return datetime(today.year, today.month, today.day, t[0], t[1])
        return None

    # авто-увеличение высоты многострочного TextField
    def _autogrow_textfield(self, tf: ft.TextField, *, min_lines=2, max_lines=14, wrap_at=60):
        text = tf.value or ""
        # грубо оцениваем количество строк с учётом переносов
        lines = text.splitlines() or [""]
        est = sum((len(l) // wrap_at) + 1 for l in lines)
        h = max(min_lines, min(est, max_lines))
        tf.min_lines = h
        tf.max_lines = h


    # ===== сервис =====
    def _priority_badge(self, priority: int) -> ft.Control:
        if priority <= 0:
            return ft.Container(width=0)
        return ft.Container(
            content=ft.Text(
                priority_label(priority, short=True),
                size=10,
                weight=ft.FontWeight.W_500,
                color=priority_color(priority),
            ),
            bgcolor=priority_bgcolor(priority),
            padding=ft.padding.symmetric(horizontal=6, vertical=2),
            border_radius=ft.border_radius.all(6),
        )

    def _toast(self, text: str):
        self.app.page.snack_bar = ft.SnackBar(ft.Text(text))
        self.app.page.snack_bar.open = True
        self.app.page.update()
    

```

### ui/pages/history.py
```python
# planner/ui/pages/history.py
from __future__ import annotations

from datetime import datetime, date
from typing import Optional, List

import flet as ft

from services.tasks import TaskService
from core.priorities import (
    priority_options,
    priority_label,
    priority_color,
    priority_bgcolor,
    normalize_priority,
)

_STATUS_LABELS = {
    "todo": "К выполнению",
    "doing": "В работе",
    "done": "Выполнено",
}


class HistoryPage:
    def __init__(self, app):
        self.app = app
        self.svc = TaskService()

        self.search_tf = ft.TextField(
            label="Поиск",
            hint_text="Введите текст для поиска по названию и заметкам",
            expand=True,
            prefix=ft.Icon(ft.Icons.SEARCH),
            on_submit=self._on_filters_changed,
            on_change=self._on_filters_changed,
        )

        self.start_tf = ft.TextField(label="Дата c", width=150)
        self.end_tf = ft.TextField(label="Дата по", width=150)

        self.start_picker = ft.DatePicker(
            first_date=date(2000, 1, 1),
            last_date=date(2100, 12, 31),
            on_change=lambda e: self._set_date(self.start_tf, e.data or e.control.value),
            on_dismiss=lambda e: self._set_date(self.start_tf, e.control.value),
        )
        self.end_picker = ft.DatePicker(
            first_date=date(2000, 1, 1),
            last_date=date(2100, 12, 31),
            on_change=lambda e: self._set_date(self.end_tf, e.data or e.control.value),
            on_dismiss=lambda e: self._set_date(self.end_tf, e.control.value),
        )

        for picker in (self.start_picker, self.end_picker):
            if picker not in self.app.page.overlay:
                self.app.page.overlay.append(picker)

        self.start_btn = ft.IconButton(
            icon=ft.Icons.CALENDAR_MONTH,
            tooltip="Выбрать дату",
            on_click=lambda e: self.app.page.open(self.start_picker),
        )
        self.end_btn = ft.IconButton(
            icon=ft.Icons.CALENDAR_MONTH,
            tooltip="Выбрать дату",
            on_click=lambda e: self.app.page.open(self.end_picker),
        )

        status_options = [
            ft.dropdown.Option("all", "Любой статус"),
            ft.dropdown.Option("todo", _STATUS_LABELS["todo"]),
            ft.dropdown.Option("doing", _STATUS_LABELS["doing"]),
            ft.dropdown.Option("done", _STATUS_LABELS["done"]),
        ]
        self.status_dd = ft.Dropdown(
            label="Статус",
            width=180,
            value="all",
            options=status_options,
            on_change=self._on_filters_changed,
        )

        priority_opts = [ft.dropdown.Option(key, label) for key, label in priority_options().items()]
        priority_opts.insert(0, ft.dropdown.Option("-1", "Любой приоритет"))
        self.priority_dd = ft.Dropdown(
            label="Приоритет",
            width=200,
            value="-1",
            options=priority_opts,
            on_change=self._on_filters_changed,
        )

        self.reset_btn = ft.TextButton("Сбросить", icon=ft.Icons.REFRESH, on_click=self._on_reset)

        filters_row = ft.Column(
            controls=[
                ft.Row([self.search_tf], alignment=ft.MainAxisAlignment.START),
                ft.Row(
                    [
                        ft.Row([self.start_tf, self.start_btn], spacing=6),
                        ft.Row([self.end_tf, self.end_btn], spacing=6),
                        self.status_dd,
                        self.priority_dd,
                        self.reset_btn,
                    ],
                    alignment=ft.MainAxisAlignment.START,
                    vertical_alignment=ft.CrossAxisAlignment.END,
                    spacing=12,
                ),
            ],
            spacing=12,
        )

        self.result_info = ft.Text("", size=12, color="#6B7280")
        self.result_list = ft.ListView(expand=True, spacing=8)

        self.view = ft.Container(
            content=ft.Column(
                [
                    ft.Text("История", size=24, weight=ft.FontWeight.BOLD),
                    filters_row,
                    self.result_info,
                    ft.Container(content=self.result_list, expand=True),
                ],
                spacing=16,
                expand=True,
            ),
            expand=True,
            padding=20,
        )

        self.run_search()

    def activate_from_menu(self):
        # Пересчитать результаты при возвращении на вкладку.
        self.run_search()

    # ---------- Filters ----------
    def _on_filters_changed(self, _):
        self.run_search()

    def _on_reset(self, _):
        self.search_tf.value = ""
        self.start_tf.value = ""
        self.end_tf.value = ""
        self.status_dd.value = "all"
        self.priority_dd.value = "-1"
        self.app.page.update()
        self.run_search()

    # ---------- Data ----------
    def run_search(self):
        start_date = self._parse_date(self.start_tf.value)
        end_date = self._parse_date(self.end_tf.value)

        priority_value = self.priority_dd.value
        priority = None if priority_value in (None, "-1") else normalize_priority(priority_value)

        tasks = self.svc.search_history(
            query=self.search_tf.value or "",
            start_date=start_date,
            end_date=end_date,
            status=self.status_dd.value,
            priority=priority,
        )

        self._render_results(tasks)
        self.app.page.update()

    def _render_results(self, tasks: List):
        total = len(tasks)
        if total == 0:
            self.result_info.value = "Ничего не найдено"
        else:
            self.result_info.value = f"Найдено {total} задач"

        self.result_list.controls.clear()
        for t in tasks:
            self.result_list.controls.append(self._task_card(t))

    # ---------- Helpers ----------
    def _task_card(self, task):
        title = task.title or "(без названия)"
        priority = getattr(task, "priority", 0)
        start = getattr(task, "start", None)
        created = getattr(task, "created_at", None)
        updated = getattr(task, "updated_at", None)
        duration = getattr(task, "duration_minutes", None)

        subtitle_parts: List[str] = []
        if start:
            if isinstance(start, datetime) and start.time() == datetime.min.time():
                subtitle_parts.append(start.strftime("Начало: %d.%m.%Y"))
            else:
                subtitle_parts.append(start.strftime("Начало: %d.%m.%Y %H:%M"))
        if duration:
            subtitle_parts.append(f"Длительность: {duration} мин")
        status_label = _STATUS_LABELS.get(getattr(task, "status", ""), "Неизвестно")
        subtitle_parts.append(f"Статус: {status_label}")
        subtitle_parts.append(f"Приоритет: {priority_label(priority, short=False)}")
        if created:
            subtitle_parts.append(f"Создано: {created.strftime('%d.%m.%Y %H:%M')}")
        if updated and (not created or updated != created):
            subtitle_parts.append(f"Обновлено: {updated.strftime('%d.%m.%Y %H:%M')}")

        note = (task.notes or "").strip()
        note_text = ft.Text(note, size=12, color="#6B7280")
        note_block = ft.Container()
        if note:
            note_block = ft.Container(
                content=note_text,
                padding=ft.padding.only(top=8),
            )

        badge = self._priority_badge(priority)

        body = ft.Column(
            [
                ft.Row(
                    [
                        badge,
                        ft.Text(title, size=16, weight=ft.FontWeight.W_600),
                    ],
                    spacing=12,
                    vertical_alignment=ft.CrossAxisAlignment.CENTER,
                ),
                ft.Text(" · ".join(subtitle_parts), size=12, color="#6B7280"),
                note_block,
            ],
            spacing=4,
        )

        bgcolor = ft.Colors.with_opacity(0.04, priority_color(priority)) if priority else "#F1F5F9"

        return ft.Card(
            content=ft.Container(
                content=body,
                padding=16,
                bgcolor=bgcolor,
            )
        )

    def _priority_badge(self, priority: int):
        if priority <= 0:
            return ft.Container(width=0)
        return ft.Container(
            content=ft.Text(
                priority_label(priority, short=True),
                size=11,
                weight=ft.FontWeight.W_600,
                color=priority_color(priority),
            ),
            bgcolor=priority_bgcolor(priority),
            padding=ft.padding.symmetric(horizontal=8, vertical=4),
            border_radius=ft.border_radius.all(8),
        )

    def _set_date(self, tf: ft.TextField, value):
        v = value
        if isinstance(v, date):
            tf.value = v.strftime("%d.%m.%Y")
        elif isinstance(v, str):
            try:
                tf.value = datetime.strptime(v[:10], "%Y-%m-%d").strftime("%d.%m.%Y")
            except ValueError:
                try:
                    tf.value = datetime.strptime(v, "%d.%m.%Y").strftime("%d.%m.%Y")
                except ValueError:
                    return
        self.app.page.update()

    def _parse_date(self, text: Optional[str]) -> Optional[date]:
        text = (text or "").strip()
        if not text:
            return None
        try:
            dt = datetime.strptime(text, "%d.%m.%Y")
            return dt.date()
        except ValueError:
            return None

```

### ui/pages/settings.py
```python
# ui/pages/settings.py
import flet as ft

class SettingsPage:
    def __init__(self, app):
        self.app = app
        self.status = ft.Text("Google: не подключено")
        if getattr(self.app.gcal, "calendar_id", None):
            self.status.value = f"Google: подключено (календарь: {self.app.gcal.calendar_id})"

        self.connect_btn = ft.ElevatedButton(
            "Подключить Google",
            icon=ft.Icons.LINK,          # в Flet 0.28+: ft.Icons.*
            on_click=self.connect_google
        )

        content = ft.Column(
            controls=[
                ft.Text("Настройки", size=24, weight=ft.FontWeight.BOLD),
                self.status,
                self.connect_btn,
            ],
            expand=True,
            spacing=16,
        )

        # В Flet 0.28 отступы задаём контейнером:
        self.view = ft.Container(content=content, expand=True, padding=20)

    def connect_google(self, _):
        try:
            self.app.gcal.connect()
            self.status.value = f"Google: подключено (календарь: {self.app.gcal.calendar_id})"
            self.app.page.snack_bar = ft.SnackBar(ft.Text("Google подключён"))
            self.app.page.snack_bar.open = True
            self.app.page.update()
        except Exception as e:
            self.status.value = f"Ошибка: {e}"
            self.app.page.update()

```

### ui/pages/today.py
```python
# planner/ui/pages/today.py
import re
from datetime import datetime, date, timedelta, time as dt_time
import flet as ft

from services.tasks import TaskService
from core.priorities import (
    priority_options,
    priority_label,
    priority_color,
    normalize_priority,
)


class TodayPage:
    LIST_SECTION_HEIGHT = 440

    def __init__(self, app):
        self.app = app
        self.svc = TaskService()
        self.edit_dialog: ft.AlertDialog | None = None

        # ---------- Быстрый ввод ----------
        self.title_tf = ft.TextField(
            label="Название задачи",
            hint_text="Например: Позвонить Ивану",
            expand=True,
            prefix=ft.Icon(ft.Icons.TASK_ALT),
        )

        self.date_tf = ft.TextField(
            label="Дата", hint_text="напр.: 10.10.2025", width=160
        )
        self.time_tf = ft.TextField(
            label="Время", hint_text="чч:мм", width=120
        )


        # В 0.28.3 дата надёжно приходит через control.value, иногда только в on_dismiss
        self.date_picker_add = ft.DatePicker(
            first_date=date(2000, 1, 1),
            last_date=date(2100, 12, 31),
            on_change=lambda e: self._set_tf_date(self.date_tf, e.data or e.control.value),
            on_dismiss=lambda e: self._set_tf_date(self.date_tf, e.control.value),
        )

        # TimePicker
        self.time_picker_add = self._new_time_picker()

        for p in (self.date_picker_add, self.time_picker_add):
            if p not in self.app.page.overlay:
                self.app.page.overlay.append(p)

        self.date_btn = ft.IconButton(
            icon=ft.Icons.CALENDAR_MONTH, tooltip="Календарь",
            on_click=lambda e: self.app.page.open(self.date_picker_add)
        )
        self.time_btn = ft.IconButton(
            icon=ft.Icons.SCHEDULE,
            tooltip="Выбрать время",
            on_click=lambda e: self._open_time_picker(self.time_picker_add, self.time_tf),
        )

        self.dur_tf = ft.TextField(label="Длительность, мин", value="30", width=160, prefix=ft.Icon(ft.Icons.TIMER))
        self.priority_dd = ft.Dropdown(
            label="Приоритет",
            width=160,
            value=str(0),
            options=[ft.dropdown.Option(key, label) for key, label in priority_options().items()],
        )
        self.to_calendar_cb = ft.Checkbox(label="Сразу в календарь", value=True)
        self.add_btn = ft.FilledButton("Добавить", icon=ft.Icons.ADD, on_click=self.on_add)

        quick_add = ft.Card(
            content=ft.Container(
                content=ft.Column(
                    [
                        ft.Text("Быстрый ввод", size=18, weight=ft.FontWeight.W_600),
                        ft.Row(
                            [
                                self.title_tf,
                                ft.Row([self.date_tf, self.date_btn], spacing=6),
                                ft.Row([self.time_tf, self.time_btn], spacing=6),
                                self.dur_tf,
                                self.priority_dd,
                                self.to_calendar_cb,
                                self.add_btn,
                            ],
                            alignment=ft.MainAxisAlignment.START,
                            vertical_alignment=ft.CrossAxisAlignment.END,
                        ),
                    ],
                    spacing=12,
                ),
                padding=16,
            )
        )

        self.today_list = ft.ListView(expand=True, spacing=12)
        self.unscheduled_list = ft.ListView(expand=True, spacing=12)

        today_card = ft.Card(
            content=ft.Container(
                padding=16,
                content=ft.Column(
                    [
                        ft.Text("Сегодня", size=18, weight=ft.FontWeight.W_600),
                        ft.Container(content=self.today_list, height=self.LIST_SECTION_HEIGHT),
                    ],
                    spacing=12,
                ),
            )
        )
        unscheduled_card = ft.Card(
            content=ft.Container(
                padding=16,
                content=ft.Column(
                    [
                        ft.Text("Без даты", size=18, weight=ft.FontWeight.W_600),
                        ft.Container(content=self.unscheduled_list, height=self.LIST_SECTION_HEIGHT),
                    ],
                    spacing=12,
                ),
            )
        )

        lists_row = ft.Row(
            [
                ft.Container(content=today_card, expand=True),
                ft.Container(content=unscheduled_card, expand=True),
            ],
            spacing=16,
            vertical_alignment=ft.CrossAxisAlignment.START,
        )

        self.view = ft.Container(
            content=ft.Column(
                [
                    ft.Text("Задачи", size=24, weight=ft.FontWeight.BOLD),
                    quick_add,
                    lists_row,
                ],
                spacing=16,
                expand=True,
            ),
            expand=True,
            padding=20,
        )

        self.refresh_lists()
    
    # --- вызов из меню/автообновления ---
    def activate_from_menu(self):
        self.load()

    def load(self):
        # алиас для унификации с календарём
        self.refresh_lists()

    # ---------- Утилиты ----------
    def _new_time_picker(self) -> ft.TimePicker:
        picker = ft.TimePicker(help_text="Выберите время")
        picker.on_change = lambda e, _picker=picker: self._time_picker_on_change(_picker, e)
        picker.on_dismiss = lambda e, _picker=picker: self._time_picker_on_dismiss(_picker, e)
        return picker

    def _open_time_picker(self, picker: ft.TimePicker, tf: ft.TextField):
        prev = tf.value
        parsed = self._parse_time_tf(tf.value)
        if parsed:
            base_time = dt_time(parsed[0], parsed[1])
        else:
            now = datetime.now()
            base_time = dt_time(now.hour, now.minute)
        try:
            picker.value = base_time
        except Exception:
            pass
        picker.data = {"tf": tf, "prev": prev, "applied": False}
        if picker not in self.app.page.overlay:
            self.app.page.overlay.append(picker)
        self.app.page.open(picker)

    def _time_picker_on_change(self, picker: ft.TimePicker, e: ft.ControlEvent):
        data = picker.data or {}
        tf = data.get("tf")
        if not tf:
            return
        value = e.data or picker.value
        if value:
            self._set_tf_time(tf, value)
            data["applied"] = True
            picker.data = data

    def _time_picker_on_dismiss(self, picker: ft.TimePicker, e: ft.ControlEvent):
        data = picker.data or {}
        tf = data.get("tf")
        if not tf:
            picker.data = None
            return
        value = e.data
        if value:
            self._set_tf_time(tf, value)
            data["applied"] = True
        elif not data.get("applied"):
            tf.value = data.get("prev", tf.value)
            self.app.page.update()
        picker.data = None

    def _set_tf_date(self, tf: ft.TextField, value):
        from datetime import date as _date, datetime

        v = value  # сюда вы передаёте e.data or e.control.value

        # Если пришёл объект date
        if isinstance(v, _date):
            tf.value = v.strftime("%d.%m.%Y")

        # Если пришла строка
        elif isinstance(v, str) and v.strip():
            s = v.strip()

            # 1) ISO 'YYYY-MM-DD'
            try:
                tf.value = datetime.strptime(s, "%Y-%m-%d").strftime("%d.%m.%Y")
            except ValueError:
                # 2) 'YYYY-MM-DDTHH:MM:SS...' -> берём дату до 'T'
                if "T" in s:
                    try:
                        tf.value = datetime.strptime(s.split("T")[0], "%Y-%m-%d").strftime("%d.%m.%Y")
                    except ValueError:
                        pass
                else:
                    # 3) уже 'DD.MM.YYYY' — оставляем как есть, если валидно
                    try:
                        datetime.strptime(s, "%d.%m.%Y")
                        tf.value = s
                    except ValueError:
                        # не распознали — ничего не меняем
                        return

        # Обновляем UI
        self.app.page.update()

    def _set_tf_time(self, tf: ft.TextField, value):
        """
        Унифицирует значение из TimePicker в формат HH:MM.
        Поддерживает: datetime.time, "HH:MM", "HH:MM:SS".
        """
        if value in (None, ""):
            return

        # если пришёл time-объект
        try:
            tf.value = value.strftime("%H:%M")
            self.app.page.update()
            return
        except Exception:
            pass

        # строковые варианты
        s = str(value or "").strip()
        m = re.match(r"^(\d{1,2}):(\d{2})(?::(\d{2}))?$", s)
        if m:
            h = int(m.group(1))
            mm = int(m.group(2))
            if 0 <= h <= 23 and 0 <= mm <= 59:
                tf.value = f"{h:02d}:{mm:02d}"
        self.app.page.update()


    def _parse_date_tf(self, s: str):
        s = (s or "").strip()
        m = re.match(r"^\s*(\d{1,2})\.(\d{1,2})\.(\d{4})\s*$", s)
        if not m:
            return None
        d, mth, y = int(m.group(1)), int(m.group(2)), int(m.group(3))
        try:
            return date(y, mth, d)
        except ValueError:
            return None

    def _parse_time_tf(self, s: str):
        """
        Возвращает (hour, minute) или None. Допускает секунды.
        """
        s = (s or "").strip()
        m = re.match(r"^\s*(\d{1,2}):(\d{2})(?::\d{2})?\s*$", s)
        if not m:
            return None
        h, minute = int(m.group(1)), int(m.group(2))
        if 0 <= h <= 23 and 0 <= minute <= 59:
            return h, minute
        return None

    def _combine_dt(self, date_str: str, time_str: str):
        d = self._parse_date_tf(date_str)
        t = self._parse_time_tf(time_str)
        if d and t:
            return datetime(d.year, d.month, d.day, t[0], t[1])
        if d and not t:
            return datetime(d.year, d.month, d.day)  # без времени
        if not d and t:
            now = datetime.now()
            cand = datetime(now.year, now.month, now.day, t[0], t[1])
            if cand < now - timedelta(minutes=1):
                cand += timedelta(days=1)
            return cand
        return None

    # ---------- CRUD ----------
    def on_add(self, _):
        title = (self.title_tf.value or "").strip()
        if not title:
            return self._toast("Введите название задачи")

        if self.date_tf.value and self._parse_date_tf(self.date_tf.value) is None:
            return self._toast("Неверный формат даты. Пример: 10.10.2025")
        if self.time_tf.value and self._parse_time_tf(self.time_tf.value) is None:
            return self._toast("Неверный формат времени. Пример: 09:30")

        start_dt = self._combine_dt(self.date_tf.value, self.time_tf.value)

        try:
            duration = int(self.dur_tf.value) if self.dur_tf.value else None
        except ValueError:
            return self._toast("Длительность должна быть числом (мин)")

        priority = normalize_priority(self.priority_dd.value)

        task = self.svc.add(
            title=title,
            start=start_dt,
            duration_minutes=duration,
            priority=priority,
        )

        msg = "Задача добавлена"
        if self.to_calendar_cb.value and start_dt and duration:
            try:
                ev = self.app.gcal.create_event_for_task(task, start_dt, duration)
                self.svc.set_event_id(task.id, ev["id"])
                msg = "Задача добавлена и запланирована в Google"
            except Exception as e:
                msg = f"Создана локально, Google недоступен: {e}"

        self.title_tf.value = ""
        self.date_tf.value = ""
        self.time_tf.value = ""
        self.dur_tf.value = "30"
        self.priority_dd.value = str(priority)
        self.refresh_lists()
        self._toast(msg)

    def on_toggle_done(self, task_id: int, checked: bool):
        self.svc.set_status(task_id, "done" if checked else "todo")
        self.refresh_lists()

    def on_delete(self, task_id: int, gcal_event_id: str | None):
        if gcal_event_id:
            try:
                self.app.gcal.delete_event_by_id(gcal_event_id)
            except Exception:
                pass
        self.svc.delete(task_id)
        self.refresh_lists()
        self._toast("Задача удалена")

    def on_edit_click(self, e: ft.ControlEvent):
        self.open_edit_dialog(int(e.control.data))

    # ---------- Рендер ----------
    def refresh_lists(self):
        from datetime import date as _date
        self.today_list.controls.clear()
        for t in self.svc.list_for_day(_date.today()):
            self.today_list.controls.append(self._row_for_task(t))
        self.unscheduled_list.controls.clear()
        for t in self.svc.list_unscheduled():
            self.unscheduled_list.controls.append(self._row_for_task(t))
        self.app.cleanup_overlays()
        self.app.page.update()

    def _row_for_task(self, t):
        meta = self._human_time(t)
        checkbox = ft.Checkbox(
            value=(t.status == "done"),
            on_change=lambda e, tid=t.id: self.on_toggle_done(tid, e.control.value),
        )

        checkbox_holder = ft.Container(
            width=52,
            alignment=ft.alignment.center,
            content=checkbox,
        )

        priority_marker = self._priority_marker(t.priority)

        title_text = ft.Text(
            t.title,
            weight=ft.FontWeight.W_600,
            size=15,
            max_lines=2,
            overflow=ft.TextOverflow.ELLIPSIS,
        )

        meta_items = []
        if getattr(t, "priority", 0) > 0:
            meta_items.append(
                ft.Container(
                    content=ft.Text(
                        priority_label(t.priority, short=True),
                        size=12,
                        weight=ft.FontWeight.W_500,
                        color=ft.Colors.WHITE,
                    ),
                    bgcolor=priority_color(t.priority),
                    padding=ft.padding.symmetric(horizontal=10, vertical=4),
                    border_radius=999,
                )
            )
        meta_items.append(
            ft.Text(
                meta,
                color=ft.Colors.BLUE_GREY_400,
                size=12,
            )
        )
        if t.gcal_event_id:
            meta_items.append(
                ft.Row(
                    controls=[
                        ft.Icon(ft.Icons.LINK, size=14),
                        ft.Text("Google", size=12, color=ft.Colors.BLUE_GREY_400),
                    ],
                    spacing=4,
                    vertical_alignment=ft.CrossAxisAlignment.CENTER,
                )
            )

        info_column = ft.Column(
            controls=[
                ft.Row(
                    controls=[priority_marker, title_text],
                    spacing=12,
                    vertical_alignment=ft.CrossAxisAlignment.CENTER,
                ),
                ft.Row(meta_items, spacing=12, wrap=True),
            ],
            spacing=6,
            alignment=ft.MainAxisAlignment.CENTER,
            expand=True,
        )

        actions = ft.Row(
            controls=[
                ft.IconButton(
                    icon=ft.Icons.EDIT_OUTLINED,
                    tooltip="Редактировать",
                    data=t.id,
                    on_click=self.on_edit_click,
                    style=ft.ButtonStyle(padding=ft.padding.all(8)),
                ),
                ft.IconButton(
                    icon=ft.Icons.DELETE_OUTLINE,
                    tooltip="Удалить",
                    on_click=lambda e, tid=t.id, ev=t.gcal_event_id: self.on_delete(tid, ev),
                    style=ft.ButtonStyle(padding=ft.padding.all(8)),
                ),
            ],
            spacing=4,
            vertical_alignment=ft.CrossAxisAlignment.CENTER,
        )

        content_row = ft.Row(
            controls=[checkbox_holder, info_column, actions],
            alignment=ft.MainAxisAlignment.SPACE_BETWEEN,
            vertical_alignment=ft.CrossAxisAlignment.CENTER,
        )

        return ft.Container(
            content=content_row,
            padding=ft.padding.symmetric(horizontal=16, vertical=12),
            border_radius=12,
            bgcolor=ft.Colors.SURFACE,
            border=ft.border.all(1, ft.Colors.with_opacity(0.08, ft.Colors.ON_SURFACE)),
        )

    # ---------- Диалог редактирования ----------
    def open_edit_dialog(self, task_id: int):
        t = self.svc.get(task_id)
        if not t:
            return self._toast("Задача не найдена")

        # --- поля без expand, фикс-ширины только там, где нужно ---
        title_tf = ft.TextField(label="Название", value=t.title, width=420)

        date_val = t.start.strftime("%d.%m.%Y") if t.start else ""
        time_val = t.start.strftime("%H:%M") if (t.start and t.start.time() != datetime.min.time()) else ""

        date_tf = ft.TextField(label="Дата", value=date_val, width=160)
        time_tf = ft.TextField(label="Время", value=time_val, width=120)


        # Пикеры (значения забираем из e.data или control.value)
        dp = ft.DatePicker(
            first_date=date(2000, 1, 1),
            last_date=date(2100, 12, 31),
            on_change=lambda e: self._set_tf_date(date_tf, e.data or e.control.value),
            on_dismiss=lambda e: self._set_tf_date(date_tf, e.control.value),
        )
        tp = self._new_time_picker()
        for p in (dp, tp):
            if p not in self.app.page.overlay:
                self.app.page.overlay.append(p)

        date_btn = ft.IconButton(
            icon=ft.Icons.CALENDAR_MONTH,
            tooltip="Календарь",
            on_click=lambda e, _dp=dp: self.app.page.open(_dp),
        )
        time_btn = ft.IconButton(
            icon=ft.Icons.SCHEDULE,
            tooltip="Выбрать время",
            on_click=lambda e, _tp=tp: self._open_time_picker(_tp, time_tf),
        )

        dur_tf = ft.TextField(
            label="Длительность, мин",
            value=(str(t.duration_minutes) if t.duration_minutes else ""),
            width=140
        )
        priority_dd = ft.Dropdown(
            label="Приоритет",
            width=160,
            value=str(getattr(t, "priority", 0)),
            options=[ft.dropdown.Option(key, label) for key, label in priority_options().items()],
        )
        notes_tf = ft.TextField(
            label="Заметки",
            value=(t.notes or ""),
            multiline=True,
            min_lines=3,
            max_lines=6,
        )

        def _remove_pickers():
            for ctrl in (dp, tp):
                try:
                    ctrl.open = False
                except Exception:
                    pass
                try:
                    if ctrl in self.app.page.overlay:
                        self.app.page.overlay.remove(ctrl)
                except Exception:
                    pass

        def _finalize_dialog():
            dlg = self.edit_dialog
            self.edit_dialog = None
            self._close_alert_dialog(dlg)

        def on_save(_):
            new_title = (title_tf.value or "").strip()
            if not new_title:
                return self._toast("Введите название")
            if date_tf.value and self._parse_date_tf(date_tf.value) is None:
                return self._toast("Неверный формат даты. Пример: 10.10.2025")
            if time_tf.value and self._parse_time_tf(time_tf.value) is None:
                return self._toast("Неверный формат времени. Пример: 09:30")

            new_start = self._combine_dt(date_tf.value, time_tf.value)
            try:
                new_dur = int(dur_tf.value) if dur_tf.value.strip() else None
            except ValueError:
                return self._toast("Длительность должна быть числом (мин)")

            updated = self.svc.update(
                task_id,
                title=new_title,
                notes=notes_tf.value,
                start=new_start,
                duration_minutes=new_dur,
                priority=normalize_priority(priority_dd.value),
            )

            # gcal-sync
            if new_start is not None and new_dur is not None:
                if updated.gcal_event_id:
                    try:
                        self.app.gcal.update_event_for_task(updated.gcal_event_id, updated, new_start, new_dur)
                    except Exception as e:
                        self._toast(f"Google: не удалось обновить: {e}")
                else:
                    try:
                        ev = self.app.gcal.create_event_for_task(updated, new_start, new_dur)
                        self.svc.set_event_id(task_id, ev["id"])
                    except Exception as e:
                        self._toast(f"Google: не удалось создать: {e}")
            else:
                if updated.gcal_event_id:
                    try:
                        self.app.gcal.delete_event_by_id(updated.gcal_event_id)
                    finally:
                        self.svc.set_event_id(task_id, None)

            _remove_pickers()
            _finalize_dialog()
            self.refresh_lists()
            self._toast("Сохранено")

        def on_cancel(_=None):
            _remove_pickers()
            _finalize_dialog()

        # --- КОМПАКТНАЯ ВЁРСТКА ---

        # ... всё, что выше (поля, пикеры, on_save/on_cancel) оставь как есть ...

        # компактная разметка без Wrap
        DATE_W, TIME_W, DUR_W = 140, 100, 120
        date_tf.width = DATE_W
        time_tf.width = TIME_W
        dur_tf.width  = DUR_W

        date_btn.icon_size = 18
        time_btn.icon_size = 18

        utils_row = ft.Row(
            controls=[date_tf, date_btn, time_tf, time_btn, dur_tf, priority_dd],
            spacing=8,
            run_spacing=12,
            wrap=True,
            alignment=ft.MainAxisAlignment.START,
            vertical_alignment=ft.CrossAxisAlignment.CENTER,
        )
        buttons_row = ft.Row(
            [ft.TextButton("Отмена", on_click=on_cancel),
            ft.FilledButton("Сохранить", icon=ft.Icons.SAVE, on_click=on_save)],
            alignment=ft.MainAxisAlignment.END,
        )

        MAX_W = 520
        self.edit_dialog = ft.AlertDialog(
            modal=False,
            inset_padding=ft.padding.all(16),
            content_padding=ft.padding.all(12),
            title=ft.Text("Редактировать задачу"),
            content=ft.Container(
                width=MAX_W,  # вместо constraints
                content=ft.Column(
                    [title_tf, utils_row, notes_tf, buttons_row],
                    spacing=10,
                    tight=True,
                    scroll=ft.ScrollMode.ADAPTIVE,
                ),
            ),
        )

        if self.edit_dialog not in self.app.page.overlay:
            self.app.page.overlay.append(self.edit_dialog)
        self.edit_dialog.open = True
        self.edit_dialog.on_dismiss = on_cancel
        self.app.page.update()



    # ---------- Вспомогательное ----------
    def _human_time(self, t):
        if t.start and t.duration_minutes:
            return f"{t.start.strftime('%d.%m %H:%M')} · {t.duration_minutes} мин"
        if t.start:
            if t.start.time() == datetime.min.time():
                return "без времени"
            return t.start.strftime("%d.%m %H:%M")
        return "без времени"

    def _priority_marker(self, priority: int) -> ft.Control:
        if priority <= 0:
            return ft.Container(width=12)
        return ft.Container(
            width=12,
            height=12,
            border_radius=6,
            bgcolor=priority_color(priority),
            tooltip=priority_label(priority),
        )

    def _toast(self, text: str):
        self.app.page.snack_bar = ft.SnackBar(ft.Text(text))
        self.app.page.snack_bar.open = True
        self.app.page.update()

    def _close_alert_dialog(self, dlg: ft.AlertDialog | None):
        if not dlg:
            return
        try:
            dlg.open = False
        except Exception:
            pass
        try:
            if dlg in self.app.page.overlay:
                self.app.page.overlay.remove(dlg)
        except Exception:
            pass
        self.app.page.update()
        self.app.cleanup_overlays()
```

